<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue-cli3发布一个npm包（踩坑指南）</title>
    <link href="/2021/06/10/technology/vue-cli3/"/>
    <url>/2021/06/10/technology/vue-cli3/</url>
    
    <content type="html"><![CDATA[<h3 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h3><p>最近项目中做了一些工具组件，想着不如打成npm包，沉淀成基础能力，也方便后面其他的项目中使用，因着之前有过相关经验了，信心满满的开搞啦😀。结果dist包顺利的打出来一引用，emmm好像找不到export的组件【尴尬】。从头顺了一遍流程，没有问题，那么。。。偏差应当就在于“脚手架升级了！”，是了没错，现在都是用vue-cli3及以上的版本创建项目了，而上一次打npm好像还是在vue-cli2的时代【我没读书我有罪😭】，遇事不决查文档，于是跑去把官网文档重新看了一遍，终于踩坑成功辽！</p><h3 id="库模式打包"><a href="#库模式打包" class="headerlink" title="库模式打包"></a>库模式打包</h3><p>在 vue cli 的官方文档中，找到了打包库模式的方法。详细文档可以参考<a href="https://cli.vuejs.org/zh/guide/build-targets.html#%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87" target="_blank" rel="noopener">vue-cli 构建目标库方法</a></p><h4 id="1-入口文件"><a href="#1-入口文件" class="headerlink" title="#1 入口文件"></a>#1 入口文件</h4><p>入口文件可以是一个 .js 或一个 .vue 文件。如果没有指定入口，则会使用 src/App.vue。这里我们新建一个index.js用于直接export组件：</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> myLib &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/views/myLib'</span></code></pre><blockquote><p>当使用一个 .vue 文件作为入口时，你的库会直接暴露这个 Vue 组件本身，因为组件始终是默认导出的内容。当你使用一个 .js 或 .ts 文件作为入口时，它可能会包含具名导出，所以库会暴露为一个模块。也就是说你的库必须在 UMD 构建中通过 window.yourLib.default 访问，或在 CommonJS 构建中通过 const myLib = require(‘mylib’).default 访问。如果你没有任何具名导出并希望直接暴露默认导出，你可以在 vue.config.js 中使用以下 webpack 配置：</p></blockquote><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  configureWebpack: &#123;    output: &#123;      libraryExport: <span class="hljs-string">'default'</span>    &#125;  &#125;&#125;</code></pre><h4 id="2-构建命令"><a href="#2-构建命令" class="headerlink" title="#2 构建命令"></a>#2 构建命令</h4><p>你可以通过下面的命令将一个单独的入口构建为一个库。</p><pre><code class="hljs javascript">vue-cli-service build --target lib --name myLib [entry]#输出结果File                     Size                     Gzippeddist/myLib.umd.min.js    <span class="hljs-number">13.28</span> kb                 <span class="hljs-number">8.42</span> kbdist/myLib.umd.js        <span class="hljs-number">20.95</span> kb                 <span class="hljs-number">10.22</span> kbdist/myLib.common.js     <span class="hljs-number">20.57</span> kb                 <span class="hljs-number">10.09</span> kb  dist/myLib.css           <span class="hljs-number">0.33</span> kb                  <span class="hljs-number">0.23</span> kb</code></pre><p>构建一个库会输出：</p><ul><li>dist/myLib.common.js：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包)</li><li>dist/myLib.umd.js：一个直接给浏览器或 AMD loader 使用的 UMD 包</li><li>dist/myLib.umd.min.js：压缩后的 UMD 构建版本</li><li>dist/myLib.css：提取出来的 CSS 文件 (可以通过在 vue.config.js 中设置 css: { extract: false } 强制内联)</li></ul><p>新建一个index.js作为入口文件<br>执行构建命令：</p><pre><code class="hljs javascript">vue-cli-service build --target lib --name myLib --dest lib src/index.js</code></pre><p>查看过文件内容后，发现 <code>myLib.umd.js</code> 使用了umd 的统一模块定义方法，可以兼容所有的模块化方式，可以使用于任意环境，正是我们所需要的。<br>​</p><h4 id="3-vue依赖"><a href="#3-vue依赖" class="headerlink" title="#3 vue依赖"></a>#3 vue依赖</h4><p>在库模式中，Vue 是外置的。这意味着包中不会有 Vue，即便你在代码中导入了 Vue。如果这个库会通过一个打包器使用，它将尝试通过打包器以依赖的方式加载 Vue；否则就会回退到一个全局的 Vue 变量。要避免此行为，可以在build命令中添加<code>--inline-vue</code>标志。</p><pre><code class="hljs javascript">vue-cli-service build --target lib --name myLib --dest lib src/index.js --inline-vue</code></pre><h4 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="#4 测试结果"></a>#4 测试结果</h4><p>将构建后的lib文件夹复制到项目中进行测试：</p><pre><code class="hljs javascript">&lt;template&gt;  &lt;div&gt;    &lt;myLib /&gt;  &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">&lt;/</span>template&gt;&lt;script&gt;<span class="hljs-keyword">import</span> &#123; Vue, Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-property-decorator'</span>;<span class="hljs-keyword">import</span> &#123; myLib &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib/myLib.umd.min.js'</span>;@Component(&#123;  components: &#123;    myLib: myLib,  &#125;,&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vue</span> </span>&#123;&#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><h5 id="尴尬-布局失控了，疯狂报错了😥"><a href="#尴尬-布局失控了，疯狂报错了😥" class="headerlink" title="尴尬~布局失控了，疯狂报错了😥"></a>尴尬~布局失控了，疯狂报错了😥</h5><h4 id="5-解决问题"><a href="#5-解决问题" class="headerlink" title="#5 解决问题"></a>#5 解决问题</h4><h5 id="问题一：丢失css样式"><a href="#问题一：丢失css样式" class="headerlink" title="问题一：丢失css样式"></a>问题一：丢失css样式</h5><p>手动导入构建后的css文件，也可以构建时通过在 vue.config.js 中设置 <code>css: { extract: false }</code>强制内联</p><blockquote><p>如果你在开发一个库或多项目仓库 (monorepo)，请注意导入 CSS 是具有副作用的。请确保在 package.json 中移除 “sideEffects”: false，否则 CSS 代码块会在生产环境构建时被 webpack 丢掉。</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">'myLib/lib/myLib.css'</span>;</code></pre><h5 id="问题二：vuex数据初始化失败"><a href="#问题二：vuex数据初始化失败" class="headerlink" title="问题二：vuex数据初始化失败"></a>问题二：vuex数据初始化失败</h5><p>排查后发现没有引入vuex依赖，导致所有store中存储的数据全部为undfined</p><blockquote><p>在构建 <a href="https://cli.vuejs.org/zh/guide/build-targets.html#web-components-%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">Web Components 组件</a>或<a href="https://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%93" target="_blank" rel="noopener">库</a>时，入口点不是 main.js ，而是 entry-wc.js 文件，因此，要在 Web Components 组件的目标中使用 vuex ，你需要在 App.vue 中初始化存储 (store):</p></blockquote><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span><span class="hljs-comment">// ...</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  store,  name: <span class="hljs-string">'App'</span>,  <span class="hljs-comment">// ...</span>&#125;</code></pre><h5 id="开始解决问题"><a href="#开始解决问题" class="headerlink" title="开始解决问题"></a>开始解决问题</h5><p>更新App.vue文件并手动挂载store：</p><pre><code class="hljs javascript">&lt;template&gt;  &lt;div id=<span class="hljs-string">"app"</span>&gt;    &lt;myLib /&gt;  &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">&lt;/</span>template&gt;&lt;script&gt;<span class="hljs-keyword">import</span> <span class="hljs-string">'element-ui/lib/theme-chalk/index.css'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'@/styles/index.scss'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'@/styles/element-variables.scss'</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span><span class="hljs-keyword">import</span> myLib <span class="hljs-keyword">from</span> <span class="hljs-string">'./views/myLib'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  store,  components: &#123; myLib &#125;&#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><p>修改构建命令：</p><pre><code class="hljs javascript">vue-cli-service build --target lib --name myLib --dest lib src/App.vue</code></pre><p>重新引入测试：</p><pre><code class="hljs javascript">&lt;template&gt;  &lt;div&gt;    &lt;myLib /&gt;  &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">&lt;/</span>template&gt;&lt;script&gt;<span class="hljs-keyword">import</span> &#123; Vue, Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-property-decorator'</span>;<span class="hljs-keyword">import</span> &#123; myLib &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./lib/myLib.umd.min.js'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'./lib/myLib.css'</span>;@Component(&#123;  components: &#123;    myLib: myLib,  &#125;,&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vue</span> </span>&#123;&#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><h5 id="测试成功！✨"><a href="#测试成功！✨" class="headerlink" title="测试成功！✨"></a>测试成功！✨</h5><h3 id="npm包发布"><a href="#npm包发布" class="headerlink" title="npm包发布"></a>npm包发布</h3><h4 id="1-更改入口文件"><a href="#1-更改入口文件" class="headerlink" title="#1 更改入口文件"></a>#1 更改入口文件</h4><p>将 package.json 的 “main”: “dist/index.js”, 入口文件修改为 <code>&quot;main&quot;:&quot;lib/myLib.umd.min.js&quot;</code>。</p><h4 id="2-简化构建命令"><a href="#2-简化构建命令" class="headerlink" title="#2 简化构建命令"></a>#2 简化构建命令</h4><p>在 package.json 中添加快捷语法，将 <code>&quot;vue-cli-service build --target lib --name myLib --dest lib src/App.vue&quot;</code> 命令简化为lib。</p><pre><code class="hljs javascript">#npm run lib 构建<span class="hljs-string">"scripts"</span>: &#123;    <span class="hljs-string">"build"</span>: <span class="hljs-string">"vue-cli-service build"</span>,    <span class="hljs-string">"lint"</span>: <span class="hljs-string">"vue-cli-service lint"</span>,    <span class="hljs-string">"dev"</span>: <span class="hljs-string">"vue-cli-service serve"</span>,    <span class="hljs-string">"lib"</span>:<span class="hljs-string">"vue-cli-service build --target lib --name myLib --dest lib src/App.vue"</span>,  &#125;,</code></pre><h4 id="3-更改包权限"><a href="#3-更改包权限" class="headerlink" title="#3 更改包权限"></a>#3 更改包权限</h4><p>设置 package.json 的<code>&quot;private&quot;: false</code>。</p><h4 id="4-登陆npm账号"><a href="#4-登陆npm账号" class="headerlink" title="#4 登陆npm账号"></a>#4 登陆npm账号</h4><ul><li><p>如果没有账号先去官网注册<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a></p></li><li><p>在终端输入<code>npm login</code>，然后输入你创建的账号，密码和邮箱登陆</p><h4 id="5-发布"><a href="#5-发布" class="headerlink" title="#5 发布"></a>#5 发布</h4></li><li><p><code>npm publish</code>发布–注意每次发布更新要修改package.json中的版本号</p></li><li><p>在项目中<code>npm install</code> 已发布的包名，导入使用</p><h4 id="6-删除"><a href="#6-删除" class="headerlink" title="#6 删除"></a>#6 删除</h4></li><li><p>删除指定版本：<code>npm unpublish</code> 包名@版本号</p></li><li><p>删除整个包： <code>npm unpublish</code> 包名 –force</p><h3 id="npm-Organization"><a href="#npm-Organization" class="headerlink" title="npm Organization"></a>npm Organization</h3><p>和同事一起给team新建了一个组织，现在我们要将这个包发布到组织下便于共同维护：</p><h4 id="1-注册组织"><a href="#1-注册组织" class="headerlink" title="#1 注册组织"></a>#1 注册组织</h4></li><li><p>去官网上创建我们的Organization <a href="https://docs.npmjs.com/creating-and-publishing-an-org-scoped-package" target="_blank" rel="noopener">官方步骤</a></p><h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="#2 初始化"></a>#2 初始化</h4></li><li><p><code>npm init --scope=&lt;org_name&gt;</code></p></li><li><p>修改package.json里面的name字段为<code>@org_name/&lt;pkg_name&gt;</code></p></li><li><p>公开包发布：<code>npm publish --access public</code> </p><h4 id="3-验证"><a href="#3-验证" class="headerlink" title="#3 验证"></a>#3 验证</h4></li><li><p>登陆官网就可以在组织下看到发布的包的信息啦！</p></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>欢迎纠错，看到会及时修改哒！❤<br>温故而知新，希望我们都可以保持本心，念念不忘，必有回响。</p>]]></content>
    
    
    <categories>
      
      <category>技术blog</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js VS 浏览器以及事件循环机制</title>
    <link href="/2020/09/13/technology/eventloop/"/>
    <url>/2020/09/13/technology/eventloop/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要梳理node.js，浏览器相关及Event Loop事件循环等，会持续补充更新哦！<br>首先我们要记住JS是一个单线程的语言。</p></blockquote><h2 id="JS同步异步"><a href="#JS同步异步" class="headerlink" title="JS同步异步"></a>JS同步异步</h2><ul><li><strong>同步阻塞</strong></li><li><strong>异步非阻塞：</strong>在涉及需要等待的操作，我们选择让程序继续运行，在等待时间结束的时候，通知一下我们的程序内容执行完毕，你可以操作这些资源了，这段等待时间并不影响你程序的继续执行，只是在未来的某个时间段（不确定），有一个操作一定会执行。</li></ul><h3 id="JS的异步方案演进史"><a href="#JS的异步方案演进史" class="headerlink" title="JS的异步方案演进史"></a>JS的异步方案演进史</h3><p>Raw Callback Style -&gt; Promise Callback Style -&gt; Generator Callback Style -&gt; Async/Await Callback<br /><strong>任务队列</strong>：先进先出</p><h2 id="JS-Engine-和-JS-Runtime"><a href="#JS-Engine-和-JS-Runtime" class="headerlink" title="JS Engine 和 JS Runtime"></a>JS Engine 和 JS Runtime</h2><ul><li><strong>Engine（执行引擎）：</strong>如V8 Engine，V8 实现并提供了 ECMAScript 标准中的所有数据类型、操作符、对象和方法（注意并没有 DOM）。<strong>Event Loop</strong> 是属于 <strong>JavaScript Runtime</strong> 的，是由宿主环境提供的（比如浏览器，node）</li><li><strong>Runtime（执行环境）：</strong>Chrome 提供了 window、DOM，而 Node.js 则是 require、process 等等。</li></ul><h2 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h2><p><strong>事件循环（Event Loop）</strong>是j<strong>s实现异步的一种方法</strong>，也是js的<strong>执行机制</strong>。</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><h3 id="怎么知道主线程执行栈为空"><a href="#怎么知道主线程执行栈为空" class="headerlink" title="怎么知道主线程执行栈为空"></a><strong>怎么知道主线程执行栈为空</strong></h3><p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><h3 id="执行规则"><a href="#执行规则" class="headerlink" title="执行规则"></a><strong>执行规则</strong></h3><ul><li>首先在执行栈（call stack）中的内容执行完毕清空后，会在事件队列（Event queue）检查一下哪些是宏任务哪些是微任务，然后执行所有的微任务，然后执行一个宏任务，之后再次执行所有的微任务。也就是说在主线程（main thread）任务执行完毕后会把任务队列中的微任务全部执行，然后再执行一个宏任务，这个宏任务执行完再次检查队列内部的微任务，有就全部执行没有就再执行一个宏任务。</li><li>JS是单线程但是浏览器是多线程。你的异步任务是浏览器开启对应的线程来执行的，最后放入JS引擎中进行执行。</li><li>所以在执行定时器、事件、ajax这些异步事件的时候是另外三个线程在执行代码，并不是JS引擎在做事情，在这些线程达到某一特定事件把任务放入JS引擎的线程中，同时GUI线程（渲染界面HTMl的线程）与JS线程是互斥的，在JS引擎执行时GUI线程会被冻结、挂起。</li></ul><h3 id="浏览器主线程常驻线程"><a href="#浏览器主线程常驻线程" class="headerlink" title="浏览器主线程常驻线程"></a>浏览器主线程常驻线程</h3><ul><li>GUI 渲染线程<ul><li>绘制页面，解析 HTML、CSS，构建 DOM 树，布局和绘制等</li><li>页面重绘和回流</li><li>与 JS 引擎线程互斥，也就是所谓的 JS 执行阻塞页面更新</li></ul></li><li>JS 引擎线程<ul><li>负责 JS 脚本代码的执行</li><li>负责执行准备好待执行的事件，即定时器计数结束，或异步请求成功并正确返回的事件</li><li>与 GUI 渲染线程互斥，执行时间过长将阻塞页面的渲染</li></ul></li><li>事件触发线程<ul><li>负责将准备好的事件交给 JS 引擎线程执行</li><li>多个事件加入任务队列的时候需要排队等待(JS 的单线程)</li></ul></li><li>定时器触发线程<ul><li>负责执行异步的定时器类的事件，如 setTimeout、setInterval</li><li>定时器到时间之后把注册的回调加到任务队列的队尾</li></ul></li><li>HTTP 请求线程<ul><li>负责执行异步请求</li><li>主线程执行代码遇到异步请求的时候会把函数交给该线程处理，当监听到状态变更事件，如果有回调函数，该线程会把回调函数加入到任务队列的队尾等待执行</li></ul></li></ul><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><ul><li><strong>macro-task(宏任务)</strong>：包括整体代码script，setTimeout，setInterval，I/O、UI Rendering等</li><li><strong>micro-task(微任务)</strong>：Promise.then catch finally(注意不是说 Promise，new promise直接执行)，process.nextTick，MutationObserver</li></ul><h4 id="setTimeout-fn-0"><a href="#setTimeout-fn-0" class="headerlink" title="setTimeout(fn,0)"></a>setTimeout(fn,0)</h4><p>指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。<strong>（关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。）</strong></p><h4 id="setInterval-fn-0"><a href="#setInterval-fn-0" class="headerlink" title="setInterval(fn,0)"></a>setInterval(fn,0)</h4><p>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。每过ms秒，会有fn进入Event Queue。一旦setInterval的<strong>回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了</strong>。</p><h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h4><p><strong>请求动画帧，是一个宏任务，</strong>html5 提供的一个专门用于请求动画的API，相比起setTimeout由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿。</p><h4 id="Promise与process-nextTick-callback"><a href="#Promise与process-nextTick-callback" class="headerlink" title="Promise与process.nextTick(callback)"></a>Promise与process.nextTick(callback)</h4><p>process.nextTick(callback):类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。<br />不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。</p><h3 id="执行和运行的区别"><a href="#执行和运行的区别" class="headerlink" title="执行和运行的区别"></a><strong>执行和运行的区别</strong></h3><p>执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。</p><h3 id="一些特殊的点"><a href="#一些特殊的点" class="headerlink" title="一些特殊的点"></a>一些特殊的点</h3><ul><li>async 隐式返回 Promise 作为结果，执行完 await 之后直接跳出 async 函数，让出执行的所有权，当前任务的其他代码执行完之后再次获得执行权进行执行</li><li>立即 resolve 的 Promise 对象，是在本轮”事件循环”的结束时执行，而不是在下一轮”事件循环”的开始时</li><li>在一轮event loop中多次修改同一dom，只有最后一次会进行绘制。</li><li>渲染更新（Update the rendering）会在event loop中的tasks和microtasks完成后进行，但并不是每轮event loop都会更新渲染，这取决于是否修改了dom和浏览器觉得是否有必要在此时立即将新状态呈现给用户。如果在一帧的时间内（时间并不确定，因为浏览器每秒的帧数总在波动，16.7ms只是估算并不准确）修改了多处dom，浏览器可能将变动积攒起来，只进行一次绘制，这是合理的。</li><li>如果希望在每轮event loop都即时呈现变动，可以使用requestAnimationFrame。</li></ul><h2 id="Node下的-Event-Loop"><a href="#Node下的-Event-Loop" class="headerlink" title="Node下的 Event Loop"></a>Node下的 Event Loop</h2><p>基于libuv实现，而libuv是 Node 的新跨平台抽象层，libuv使用异步IO事件驱动的编程方式，核心是提供i/o的事件循环和异步回调。libuv的API包含有时间，非阻塞的网络，异步文件操作，子进程等等。</p><h3 id="六个阶段"><a href="#六个阶段" class="headerlink" title="六个阶段"></a>六个阶段</h3><ul><li><strong>timers</strong>：执行setTimeout() 和 setInterval()中到期的callback。</li><li><strong>pending callback</strong>: 上一轮循环中有少数的I/O callback会被延迟到这一轮的这一阶段执行</li><li><strong>idle, prepare</strong>：仅内部使用</li><li><strong>poll</strong>: 最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段</li><li><strong>check</strong>: 执行setImmediate的callback</li><li><strong>close callbacks</strong>: 执行close事件的callback，例如socket.on(‘close’[,fn])、http.server.on(‘close, fn)</li></ul><h2 id="Node与浏览器的-Event-Loop-差异"><a href="#Node与浏览器的-Event-Loop-差异" class="headerlink" title="Node与浏览器的 Event Loop 差异"></a>Node与浏览器的 Event Loop 差异</h2><ul><li>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。</li><li>而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。</li></ul><br />> node.js 是⼀个 JS 的服务端运⾏环境，简单的来说，是在 JS 语⾔规范的基础上，封装了⼀些服务端的运⾏时 对象，让我们能够简单实现⾮常多的业务功能。> 基于 JS 语法增加与操作系统之间的交互。<h2 id="Node的简单介绍"><a href="#Node的简单介绍" class="headerlink" title="Node的简单介绍"></a>Node的简单介绍</h2><h3 id="底层依赖"><a href="#底层依赖" class="headerlink" title="底层依赖"></a>底层依赖</h3><p>node.js 的主要依赖⼦模块有以下内容：</p><ul><li>V8 引擎：主要是 JS 语法的解析，有了它才能识别JS语法</li><li>libuv: c 语⾔实现的⼀个⾼性能异步⾮阻塞 IO 库，⽤来实现 node.js 的事件循环</li><li>http-parser/llhttp: 底层处理 http 请求，处理报⽂，解析请求包等内容</li><li>openssl: 处理加密算法，各种框架运⽤⼴泛</li><li>zlib: 处理压缩等内容</li></ul><h3 id="常见内置模块"><a href="#常见内置模块" class="headerlink" title="常见内置模块"></a>常见内置模块</h3><ul><li>*<em>fs: *</em>⽂件系统，能够读取写⼊当前安装系统环境中硬盘的数据</li><li><strong>path:</strong> 路径系统，能够处理路径之间的问题</li><li><strong>crypto:</strong> 加密相关模块，能够以标准的加密⽅式对我们的内容进⾏加解密</li><li><strong>dns:</strong> 处理 dns 相关内容，例如我们可以设置 dns 服务器等等</li><li>*<em>http: *</em>设置⼀个 http 服务器，发送 http 请求，监听响应等等</li><li><strong>readline:</strong> 读取 stdin 的⼀⾏内容，可以读取、增加、删除我们命令⾏中的内容</li><li><strong>os:</strong> 操作系统层⾯的⼀些 api，例如告诉你当前系统类型及⼀些参数</li><li><strong>vm:</strong> ⼀个专⻔处理沙箱的虚拟机模块，底层主要来调⽤ v8 相关 api 进⾏代码解析。</li></ul><h3 id="Buffer-缓冲"><a href="#Buffer-缓冲" class="headerlink" title="Buffer 缓冲"></a>Buffer 缓冲</h3><p>Buffer 类，用来创建一个专门存放二进制数据的缓存区。</p><ul><li>Buffer 是 UInt8Array </li><li>是数组，且每个item的有效范围是 0~255（无符号8位）</li><li>详细api可查 <a href="http://nodejs.cn/api/buffer.html" target="_blank" rel="noopener">http://nodejs.cn/api/buffer.html</a><pre><code class="hljs javascript">Buffer.from([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]); <span class="hljs-comment">//Buffer.from() 接口创建Buffer对象（传入的array的元素只能是数字，不然就会自动被0覆盖）</span>Buffer.from([<span class="hljs-number">257</span>, <span class="hljs-number">257.5</span>, <span class="hljs-number">-255</span>, <span class="hljs-string">'1'</span>]); <span class="hljs-comment">//都是1</span>Buffer.from(<span class="hljs-string">'abcd'</span>); <span class="hljs-comment">//utf8编码转换 &lt;Buffer 61 62 63 64&gt;</span><span class="hljs-keyword">const</span> bf = Buffer.alloc(<span class="hljs-number">256</span>); <span class="hljs-comment">//创建一个长度为 256、且用 0 填充的 Buffer</span><span class="hljs-keyword">const</span> len = buf.write(<span class="hljs-string">"www.baidu.com"</span>); <span class="hljs-comment">//写入，返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</span><span class="hljs-keyword">const</span> str1 = buf.toString(<span class="hljs-string">'utf8'</span>) <span class="hljs-comment">//// 使用 'utf8' 编码, 并输出: www.baidu.com</span><span class="hljs-keyword">const</span> str2 = buf.toString(<span class="hljs-string">'utf8'</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>) <span class="hljs-comment">//// 使用 'utf8' 编码, 并输出: www.baidu</span></code></pre></li></ul><h3 id="EventEmitter-事件"><a href="#EventEmitter-事件" class="headerlink" title="EventEmitter 事件"></a>EventEmitter 事件</h3><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p><ul><li><strong>on方法，</strong>注册事件回调</li><li><strong>emit方法，</strong>手动触发事件</li><li>详细api可查** **<a href="http://nodejs.cn/api/events.html" target="_blank" rel="noopener">http://nodejs.cn/api/events.html</a><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> EventEmitter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyEventEmitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span> </span>&#123;&#125;<span class="hljs-keyword">const</span> myEventEmitter = <span class="hljs-keyword">new</span> MyEventEmitter();myEventEmitter.on(<span class="hljs-string">'ping'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'pong'</span>);&#125;)myEventEmitter.emit(<span class="hljs-string">'ping'</span>);</code></pre></li></ul><h3 id="Stream-流"><a href="#Stream-流" class="headerlink" title="Stream 流"></a>Stream 流</h3><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）</p><ul><li>Stream 有四种流类型<ul><li><strong>Readable</strong> - 可读操作</li><li><strong>Writable</strong> - 可写操作</li><li><strong>Duplex</strong> - 可读可写操作</li><li><strong>Transform</strong> - 操作被写入数据，然后读出结果</li></ul></li><li>Stream 对象本身就是一个 EventEmitter ，常用事件有<ul><li><strong>data</strong> - 当有数据可读时触发。<br /></li><li><strong>end</strong> - 没有更多的数据可读时触发。<br /></li><li><strong>error</strong> - 在接收和写入过程中发生错误时触发。<br /></li><li><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</li></ul></li><li>Stream 内部含有 Buffer</li><li>Stream优势：只会先读文件需要的一部分，内存损耗较小</li><li>详细api可查** **<a href="http://nodejs.cn/api/stream.html" target="_blank" rel="noopener">http://nodejs.cn/api/stream.html</a><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> readerStream = fs.createReadStream(<span class="hljs-string">'input.txt'</span>,&#123;<span class="hljs-attr">start</span>:<span class="hljs-number">50</span>,<span class="hljs-attr">end</span>:<span class="hljs-number">99</span>&#125;); <span class="hljs-comment">//读取一部分</span></code></pre></li></ul><h3 id="常见全局对象"><a href="#常见全局对象" class="headerlink" title="常见全局对象"></a>常见全局对象</h3><ul><li>setTimeout 创建定时</li><li>clearTimeout(t) 停止定时</li><li>setInterval 创建轮询</li><li>clearInterval(t) 停止轮询</li><li>console 打印</li><li>process 进程</li></ul><h3 id="模块全局对象"><a href="#模块全局对象" class="headerlink" title="模块全局对象"></a>模块全局对象</h3><p>模块加载时注入</p><ul><li>__filename 模块文件的路径</li><li>__dirname  当前执行脚本所在的目录</li><li>exports 输出</li><li>module 模块</li><li>require  请求</li></ul><h3 id="npm-node-package-manager"><a href="#npm-node-package-manager" class="headerlink" title="npm(node package manager)"></a>npm(node package manager)</h3><ul><li>node.js 内置的用于安装和发布符合 node.js 标准的模块的⼀款⼯具，从⽽实现社区共建的⽬的繁荣整个社区。</li><li>npx 是 npm@5 之后新增的⼀个命令，它使得我们可以 在<strong>不安装模块</strong>到当前环境的前提下，使⽤⼀些 <strong>cli</strong> 功能，每次调用都会使用最新的版本。<pre><code class="hljs javascript"># 全局安装了 vuenpm i -g vuevue init webpack test# ⽆论是项⽬中还是全局都没有安装 vue (但实际上是安装了的，但表现确实像没有安装)npx vue test</code></pre></li></ul><h4 id="发布一个npm包"><a href="#发布一个npm包" class="headerlink" title="发布一个npm包"></a>发布一个npm包</h4><ul><li><p>安装webpack简易框架（这里以发布vue插件为例）</p><pre><code class="hljs javascript">npm install -g @vue/cli-init <span class="hljs-comment">//cli版本是3及以上，vue init 的运行效果将会跟 vue-cli@2.x 相同</span>vue init webpack-simple marquee<span class="hljs-comment">//安装完成目录结构</span>文件目录/├── index.html├── package.json├── README.md├── .babelrc├── .editorconfig├── .gitignore├── src│   ├── App.vue│   ├── assets│   │   └── logo.png│   └── main.js└── webpack.config.js</code></pre></li><li><p>封装Vue插件（创建一个index.js）</p><pre><code class="hljs javascript"><span class="hljs-comment">//在APP.vue中查看效果</span>npm installnpm run dev</code></pre></li><li><p>在index.js中export封装好的Vue插件</p></li><li><p>修改webpack.config.js</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> NODE_ENV = process.env.NODE_ENV;<span class="hljs-built_in">module</span>.exports = &#123;  entry: NODE_ENV == <span class="hljs-string">'development'</span> ? <span class="hljs-string">'./src/main.js'</span> : <span class="hljs-string">'./src/marquee/index.js'</span>,  output: &#123;    path: path.resolve(__dirname, <span class="hljs-string">'./dist'</span>),    publicPath: <span class="hljs-string">'/dist/'</span>,    filename: <span class="hljs-string">'marquee.js'</span>, <span class="hljs-comment">//输出文件名</span>    library: <span class="hljs-string">'marquee'</span>, <span class="hljs-comment">// 指定的就是你使用require时的模块名</span>    libraryTarget: <span class="hljs-string">'umd'</span>, <span class="hljs-comment">// 指定输出格式， UMD 同时支持两种执行环境：node环境、浏览器环境。</span>    umdNamedDefine: <span class="hljs-literal">true</span> <span class="hljs-comment">// 会对 UMD 的构建过程中的 AMD 模块进行命名。否则就使用匿名的 define</span>  &#125;,&#125;</code></pre></li><li><p>打包</p><pre><code class="hljs javascript">npm run build<span class="hljs-comment">//出现dist文件夹</span></code></pre></li><li><p>修改package.json</p><pre><code class="hljs javascript">&#123; <span class="hljs-string">"author"</span>: <span class="hljs-string">"maomincoding"</span>,  <span class="hljs-comment">//author的值为npm用户名，这里一定要注意</span>  <span class="hljs-string">"main"</span>: <span class="hljs-string">"dist/marquee.js"</span>, <span class="hljs-comment">//main的值为刚才打包的路径文件</span>  <span class="hljs-string">"license"</span>: <span class="hljs-string">"ISC"</span>, <span class="hljs-comment">//license的值按照以上即可</span>  <span class="hljs-string">"keywords"</span>: [<span class="hljs-string">"marquee"</span>], <span class="hljs-comment">//keywords为用户搜索的关键词</span>  <span class="hljs-string">"private"</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//private设为false, 开源因此需要将这个字段改为 false</span>&#125;</code></pre></li><li><p>发包文件名单</p><pre><code class="hljs javascript"><span class="hljs-comment">//npm发包默认包含的文件（不区分大小写）</span>package.jsonREADME (and its variants)CHANGELOG (and its variants)LICENSE / LICENCEpackage.json属性main指向的文件<span class="hljs-comment">//npm发包默认忽略的文件</span>.gitCVS.svn.hg.lock-wscript.wafpickle-N.*.swp.DS_Store._*npm-debug.log.npmrcnode_modulesconfig.gypi*.origpackage-lock.json (use shrinkwrap instead)<span class="hljs-comment">//发包白名单，设置package.json中的files属性</span>files:[<span class="hljs-string">"package.json"</span>,<span class="hljs-string">"src"</span>]<span class="hljs-comment">//发包黑名单,通过下面两个文件来设置忽略的文件或文件夹</span>.gitignore.npmignore<span class="hljs-comment">//文件设置优先级!!!</span>files&gt;.npmignore&gt;.gitignore</code></pre></li><li><p>编辑README.md</p></li><li><p>npm包发布</p><pre><code class="hljs javascript">npm config <span class="hljs-keyword">get</span> registry //查看登录源npm config <span class="hljs-keyword">set</span> registry=http://registry.npmjs.org //如果不是http://registry.npmjs.org就切换一下npm login //登录 回车出现 Logged in as maomincoding on http://registry.npmjs.org,那么就成功了npm publish //成功！</code></pre></li><li><p>npm包撤销 ：只有在发包的24小时内才允许撤销，以后发包的时候也不能再和被撤销的包的名称和版本重复了，建议慎重！<strong>I sure hope you know what you are doing</strong></p><pre><code class="hljs javascript">npm unpublish 包名 --force <span class="hljs-comment">//撤销</span></code></pre></li><li><p>npm包更新</p><ul><li>打开根目录下的package.json找到version字段 “version”:”a.b.c”<ul><li>修复bug,小改动，c加1</li><li>增加了新特性，但仍能向后兼容，b加1</li><li>有很大的改动，无法向后兼容，a加1</li></ul></li><li>再次发布</li></ul></li></ul><h3 id="nvm-node-version-manager"><a href="#nvm-node-version-manager" class="headerlink" title="nvm(node version manager)"></a>nvm(node version manager)</h3><p>管理 node 版本的⼀个⼯具,简单来说，就是通过将多个 node 版本安装在指定路径，然后通过 nvm 命令切换时，就会切换我们环境变量中 node 命令指定的实际执⾏的软件路径。</p><h3 id="nrm-npm-registry-manager"><a href="#nrm-npm-registry-manager" class="headerlink" title="nrm(npm registry manager )"></a>nrm(npm registry manager )</h3><p>是npm的镜像源管理工具，使用这个可以快速地在 npm 源间切换。</p><h3 id="服务端框架-express-koa"><a href="#服务端框架-express-koa" class="headerlink" title="服务端框架 express/koa"></a>服务端框架 express/koa</h3><p>node.js 内部有⾮常多的内置模块，其中就有 http 模块，express/koa 实际上就是 对这个 http 模块的再封装，增加了中间件策略和其他 各种路由的通⽤处理，让我们写起来更加⽅便。</p><ul><li>*<em>body-parser *</em>express处理body的中间件</li><li><strong>cookie-parser</strong> express处理cookie的中间件</li><li>中间件可以这样理解，对于需要多次书 写的业务逻辑，可以使⽤⼀种切⾯的形式，对相同逻辑进⾏通⽤处理。</li><li><strong>洋葱模型：</strong>中间件线性的连贯的，自上而下（垂直）依次进行劫持。执行到next()会跳出当前继续向下一个中间件执行，结束后会返回之前中间件执行next()后面内容。</li><li>koa和express在同步场景下完全相同，处理异步时koa进行rosolve能正确执行回调顺序，但express缺少这个方法，会产生一些顺序问题。</li></ul><h3 id="周边工具简介"><a href="#周边工具简介" class="headerlink" title="周边工具简介"></a>周边工具简介</h3><h4 id="quickjs"><a href="#quickjs" class="headerlink" title="quickjs"></a>quickjs</h4><p>quickjs 是⼀个 JS 的解析引擎，轻量代码量也不⼤，与之功能类似的就是 V8 引擎。<br />他最⼤的特点就是，⾮常⾮常轻量，这点从源码中也能提现，事实上并没有太多的代码，它的主要特点和优势：</p><ul><li>轻量⽽且易于嵌⼊：只需⼏个C⽂件，没有外部依赖，⼀个x86下的简单的“hello world”程序只要180KiB。</li><li>具有极低启动时间的快速解释器： 在⼀台单核的台式PC上，⼤约在100秒内运⾏ECMAScript 测试套件156000次。运⾏时实例的完整⽣命周期在不到300微秒的时间内完成。</li><li>⼏乎完整实现ES2019⽀持，包括： 模块，异步⽣成器和和完整Annex B⽀持 (传统的Web兼容性)。许多ES2020中带来的特性也依然会被⽀持。</li><li>通过100％的ECMAScript Test Suite测试。</li><li>可以将Javascript源编译为没有外部依赖的可执⾏⽂件。</li></ul><h4 id="deno"><a href="#deno" class="headerlink" title="deno"></a>deno</h4><p>deno 是⼀类类似于 node.js 的 JS 运⾏时环境，同时他 也是由 node.js 之⽗⼀⼿打造出来的，他和 node.js ⽐ 有什么区别呢？ </p><ul><li>相同点：<ul><li>deno 也是基于 V8 ，上层封装⼀些系统级别的调⽤ </li><li>我们的 deno 应⽤也可以使⽤ JS 开发</li></ul></li><li>不同点：<ul><li>deno 基于 rust 和 typescript 开发⼀些上层模块，所 以我们可以直接在 deno 应⽤中书写 ts </li><li>deno ⽀持从 url 加载模块，同时⽀持 top level await 等特性</li></ul></li></ul><h4 id="sequelize-ORM-框架"><a href="#sequelize-ORM-框架" class="headerlink" title="sequelize ORM 框架"></a>sequelize ORM 框架</h4><p>帮助我们抹平了 底层数据库的细节，我们使⽤这类框架，就能按照它的 语法进⾏书写，最终⽣成能够应⽤于各个平台的 sql 语句。</p><h4 id="pm2-服务部署"><a href="#pm2-服务部署" class="headerlink" title="pm2 服务部署"></a>pm2 服务部署</h4><p>使⽤ pm2 启动服务端、进⾏运维</p><pre><code class="hljs javascript">npm install -g pm2pm2 start ws-server.js —name my-serverpm2 listpm2 monitpm2 logs ws-server.js</code></pre><h2 id="问几个问题"><a href="#问几个问题" class="headerlink" title="问几个问题"></a>问几个问题</h2><p>Node下的 Event Loop</p><h3 id="Q1：下面哪几种写法可以正确导出（commonJS）"><a href="#Q1：下面哪几种写法可以正确导出（commonJS）" class="headerlink" title="Q1：下面哪几种写法可以正确导出（commonJS）"></a>Q1：下面哪几种写法可以正确导出（commonJS）</h3><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports=<span class="hljs-string">'hello word'</span> <span class="hljs-comment">//√</span>exports.key=<span class="hljs-string">'hello word'</span> <span class="hljs-comment">//√</span>exports=<span class="hljs-string">'hello word'</span> <span class="hljs-comment">//×</span></code></pre><blockquote><p>exports是module.exports值的引用，直接更改时引用地址进行了改变，不会对module.exports产生影响</p></blockquote><h3 id="Q2：自测一下"><a href="#Q2：自测一下" class="headerlink" title="Q2：自测一下"></a>Q2：自测一下</h3><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script start'</span>);setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setTimeout'</span>);&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise1'</span>);&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise2'</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script end'</span>);</code></pre><blockquote><p>script start-&gt;script end-&gt;promise1-&gt;promise2-&gt;setTimeout</p></blockquote><h3 id="Q3：再测一下"><a href="#Q3：再测一下" class="headerlink" title="Q3：再测一下"></a>Q3：再测一下</h3><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script start'</span>)<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">await</span> async2()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async1 end'</span>)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async2 end'</span>) &#125;async1()setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setTimeout'</span>)&#125;, <span class="hljs-number">0</span>)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Promise'</span>)  resolve()&#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise1'</span>)  &#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise2'</span>)  &#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script end'</span>)</code></pre><blockquote><p>script start-&gt;async2 end-&gt;Promise-&gt;script end-&gt;async1 end-&gt;promise1-&gt;promise2-&gt;setTimeout</p></blockquote><h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><ul><li><a href="https://blog.csdn.net/qq_39045645/article/details/103305510" target="_blank" rel="noopener">npm发布包以及更新包还有需要注意的几点问题（这里以发布vue插件为例）</a></li><li><a href="https://juejin.im/post/5b56c3586fb9a04faa79a8e0" target="_blank" rel="noopener">你好，JavaScript异步编程—- 理解JavaScript异步的美妙</a></li><li><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></li><li><a href="https://mp.weixin.qq.com/s/aYgtL_-seRE1iOHKGSkczw" target="_blank" rel="noopener">你不知道的 Event Loop</a></li><li><a href="https://juejin.im/post/5d901418518825539312f587" target="_blank" rel="noopener">【THE LAST TIME】彻底吃透 JavaScript 执行机制</a></li><li><a href="https://zhuanlan.zhihu.com/p/34229323" target="_blank" rel="noopener">深入理解 JavaScript Event Loop</a></li><li><a href="https://github.com/aooy/blog/issues/5" target="_blank" rel="noopener">从event loop规范探究javaScript异步及浏览器更新渲染时机</a></li><li><a href="https://juejin.im/post/5c3d8956e51d4511dc72c200" target="_blank" rel="noopener">一次弄懂Event Loop（彻底解决此类面试问题）</a></li><li><a href="https://zhuanlan.zhihu.com/p/54882306" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别?</a>**</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>欢迎纠错，看到会及时修改哒！❤<br>温故而知新，希望我们都可以保持本心，念念不忘，必有回响。</p>]]></content>
    
    
    <categories>
      
      <category>技术blog</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/07/31/hello-world/"/>
    <url>/2020/07/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工具推荐</title>
    <link href="/2020/07/31/other/issue/"/>
    <url>/2020/07/31/other/issue/</url>
    
    <content type="html"><![CDATA[<h3 id="视频播放器推荐：potplayer-https-potplayer-daum-net"><a href="#视频播放器推荐：potplayer-https-potplayer-daum-net" class="headerlink" title="视频播放器推荐：potplayer https://potplayer.daum.net/"></a>视频播放器推荐：potplayer <a href="https://potplayer.daum.net/" target="_blank" rel="noopener">https://potplayer.daum.net/</a></h3><h3 id="屏保推荐：filqlo-https-fliqlo-com"><a href="#屏保推荐：filqlo-https-fliqlo-com" class="headerlink" title="屏保推荐：filqlo  https://fliqlo.com/"></a>屏保推荐：filqlo  <a href="https://fliqlo.com/" target="_blank" rel="noopener">https://fliqlo.com/</a></h3><h3 id="贴图软件推荐：snipaste-https-www-snipaste-com"><a href="#贴图软件推荐：snipaste-https-www-snipaste-com" class="headerlink" title="贴图软件推荐：snipaste  https://www.snipaste.com/"></a>贴图软件推荐：snipaste  <a href="https://www.snipaste.com/" target="_blank" rel="noopener">https://www.snipaste.com/</a></h3><h3 id="解压缩软件推荐：bandzip-https-cn-bandisoft-com-bandizip"><a href="#解压缩软件推荐：bandzip-https-cn-bandisoft-com-bandizip" class="headerlink" title="解压缩软件推荐：bandzip  https://cn.bandisoft.com/bandizip/"></a>解压缩软件推荐：bandzip  <a href="https://cn.bandisoft.com/bandizip/" target="_blank" rel="noopener">https://cn.bandisoft.com/bandizip/</a></h3>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Other</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从头梳理JS基础（三）原型，原型链与继承</title>
    <link href="/2020/07/28/technology/js-basic3/"/>
    <url>/2020/07/28/technology/js-basic3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要梳理JS 的原型，原型链，new运算及继承等，会持续补充更新哦！</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>constructor</strong> 返回创建实例对象时构造函数的引用。此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。</p><h3 id="Symbol-是构造函数吗？"><a href="#Symbol-是构造函数吗？" class="headerlink" title="Symbol 是构造函数吗？"></a>Symbol 是构造函数吗？</h3><p><strong>Symbol</strong>是基本数据类型，但作为构造函数来说它并不完整，因为它不支持语法 <strong>new Symbol()</strong>，但其原型上拥有 <strong>constructor</strong>属性，即 <strong>Symbol.prototype.constructor</strong>。Chrome 认为其不是构造函数，如果要生成实例直接使用 <strong>Symbol()</strong>即可。</p><h3 id="constructor-值只读吗？"><a href="#constructor-值只读吗？" class="headerlink" title="constructor 值只读吗？"></a>constructor 值只读吗？</h3><p>对于引用类型来说 <strong>constructor **属性值是可以修改的，但是对于基本类型来说是只读的，创建他们的是只读的原生构造函数（</strong>native constructors<strong>），当然 *<em>null *</em>和 *<em>undefined *</em>是没有 **constructor</strong> 属性的。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><img src="http://note.youdao.com/yws/res/1500/WEBRESOURCEa8ca6b275d004664d09b4a5d52fcb741#align=left&display=inline&height=303&margin=%5Bobject%20Object%5D&originHeight=484&originWidth=992&status=done&style=none&width=620" srcset="/img/loading.gif" alt=""></p><ul><li><p>Parent 对象有一个原型对象 <strong>Parent.prototype</strong>，其上有两个属性，分别是 <strong>constructor</strong> 和 <strong><strong>proto</strong></strong>，其中 <strong>proto</strong> （访问器属性）已被弃用，推荐使用 Object.getPrototypeOf()。</p></li><li><p><strong><strong>proto</strong></strong> 是每个实例上都有的属性，<strong>prototype</strong> 是构造函数的属性，这两个并不一样，但 p.<strong>proto</strong> 和 Parent.prototype 指向同一个对象。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个对象拥有一个原型对象，通过 <strong><strong>proto</strong></strong>指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 <strong>null</strong>。</p></li><li><p>每个对象都有<strong><strong>proto</strong></strong> 属性，但只有函数对象才有 <strong>prototype *<em>属性(但 *</em>Function.prototype</strong> 除外，它是函数对象，但它很特殊，他没有<strong>prototype</strong>属性)</p></li><li><p>原型对象（<strong>Person.prototype</strong>）是 构造函数（<strong>Person</strong>）的一个实例。</p></li><li><p>所有的构造器都来自于 <strong>Function.prototype</strong>，甚至包括根构造器<strong>Object</strong>及<strong>Function</strong>自身。所有构造器都继承了<strong>Function.prototype</strong>·的属性及方法。如<strong>length、call、apply、bind</strong></p></li><li><p>所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了<strong>Object.prototype</strong>上的所有方法：<strong>toString、valueOf、hasOwnProperty</strong>等。</p></li><li><p>所有函数对象<strong>proto</strong>都指向<strong>Function.prototype</strong>，它是一个空函数<strong>Empty function</strong></p></li><li><p><strong>Object.getOwnPropertyNames,</strong>获取所有（包括不可枚举的属性）的属性名不包括 *<em>prototy *</em>中的属性，返回一个数组</p></li><li><p>如果要创建一个新对象，同时继承另一个对象的 [[Prototype]] ，推荐使用 <strong>Object.create()</strong>。</p></li><li><p>原型和原型链是JS实现继承的一种模型。</p></li><li><p>原型链的形成是真正是靠<strong><strong>proto</strong></strong> 而非<strong>prototype</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(); <span class="hljs-built_in">console</span>.log(person1.__proto__ === Person.prototype); <span class="hljs-comment">// true </span><span class="hljs-built_in">console</span>.log(Person.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">//true </span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.__proto__) <span class="hljs-comment">//null </span>Person.__proto__ == <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">//true </span><span class="hljs-built_in">Object</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// true </span><span class="hljs-built_in">Function</span>.__proto__ === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// true </span><span class="hljs-built_in">Function</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype <span class="hljs-comment">//true </span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span>.prototype)<span class="hljs-comment">// function()&#123;&#125; (空函数) </span><span class="hljs-keyword">var</span> num = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>() <span class="hljs-built_in">console</span>.log(num.__proto__ == <span class="hljs-built_in">Array</span>.prototype) <span class="hljs-comment">// true </span><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">Array</span>.prototype.__proto__ == <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// true </span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype) <span class="hljs-comment">// [] (空数组) </span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.__proto__) <span class="hljs-comment">//null </span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.__proto__ == <span class="hljs-built_in">Function</span>.prototype)<span class="hljs-comment">// true</span></code></pre></li></ul><h2 id="New运算符"><a href="#New运算符" class="headerlink" title="New运算符"></a>New运算符</h2><blockquote><p><strong>new 运算符</strong>创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。 ——（MDN）</p></blockquote><h3 id="new一个对象过程发生了什么？"><a href="#new一个对象过程发生了什么？" class="headerlink" title="new一个对象过程发生了什么？"></a>new一个对象过程发生了什么？</h3><ul><li>创建了一个全新的对象。(可以访问到构造函数和原型里的属性)</li><li>这个对象会被执行[[Prototype]]（也就是<strong>proto</strong>）链接。</li><li>生成的新对象会绑定到函数调用的this。</li><li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</li><li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。</li></ul><h3 id="模拟一个new"><a href="#模拟一个new" class="headerlink" title="模拟一个new"></a><strong>模拟一个new</strong></h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;    Constructor = [].shift.call(<span class="hljs-built_in">arguments</span>);<span class="hljs-comment">//取得外部传入的构造器</span>    <span class="hljs-comment">//var obj = &#123;&#125;  // 创建一个空对象</span>    <span class="hljs-comment">//var obj = new Object(),//从Object.prototype上克隆一个对象</span>    <span class="hljs-comment">//obj.__proto__ = Constructor.prototype;</span>    <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(Constructor.prototype);    <span class="hljs-comment">// var F = function () &#123; &#125;;</span>    <span class="hljs-comment">// F.prototype = Constructor.prototype;</span>    <span class="hljs-comment">// obj = new F();//指向正确的原型</span>    <span class="hljs-keyword">var</span> ret = Constructor.apply(obj, <span class="hljs-built_in">arguments</span>);<span class="hljs-comment">//借用外部传入的构造器给obj设置属性</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">'object'</span> ? ret||obj : obj;<span class="hljs-comment">//确保构造器总是返回一个对象</span>&#125;;</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>一个在构造函数上常用的规则是，用于复用的成员（译注：属性和方法）应该被添加到原型上。<br>代码复用才是目标，继承只是达成这个目标的一种手段。</p><h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><p>重写原型对象，代之以一个新类型的实例。<br>缺点：</p><ul><li>多个实例对引用类型的操作会被篡改。</li><li>在创建实例时，不能向SuperType传参<pre><code class="hljs javascript">SubType.prototype = <span class="hljs-keyword">new</span> SuperType();</code></pre></li></ul><h3 id="2、借用构造函数继承（经典继承）"><a href="#2、借用构造函数继承（经典继承）" class="headerlink" title="2、借用构造函数继承（经典继承）"></a>2、借用构造函数继承（经典继承）</h3><p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p><pre><code class="hljs javascript">SuperType.call(<span class="hljs-keyword">this</span>);</code></pre><p>缺点：</p><ul><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h3 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h3><p>原型链继承和经典继承双剑合璧。<br>缺点：在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p><h3 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h3><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> SubType = <span class="hljs-built_in">Object</span>.create(SuperType);</code></pre><p>缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h3 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h3><p>在原型式继承的基础上，增强对象，返回构造函数（为构造函数新增属性和方法，以增强函数）<br>缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h3 id="6、寄生组合式继承"><a href="#6、寄生组合式继承" class="headerlink" title="6、寄生组合式继承"></a>6、寄生组合式继承</h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>)</span>&#123;  <span class="hljs-keyword">var</span> prototype = <span class="hljs-built_in">Object</span>.create(superType.prototype); <span class="hljs-comment">// 创建对象，创建父类原型的一个副本</span>  prototype.constructor = subType;                    <span class="hljs-comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span>  subType.prototype = prototype;                      <span class="hljs-comment">// 指定对象，将新创建的对象赋值给子类的原型</span>&#125;<span class="hljs-comment">// 父类初始化实例属性和原型属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>)</span>&#123;  <span class="hljs-keyword">this</span>.name = name;  <span class="hljs-keyword">this</span>.colors = [<span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"green"</span>];&#125;SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  alert(<span class="hljs-keyword">this</span>.name);&#125;;<span class="hljs-comment">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>)</span>&#123;  SuperType.call(<span class="hljs-keyword">this</span>, name);  <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-comment">// 将父类原型指向子类</span>inheritPrototype(SubType, SuperType);<span class="hljs-comment">// 新增子类原型属性</span>SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  alert(<span class="hljs-keyword">this</span>.age);&#125;<span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">"xyc"</span>, <span class="hljs-number">23</span>);<span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">"lxy"</span>, <span class="hljs-number">23</span>);instance1.colors.push(<span class="hljs-string">"2"</span>); <span class="hljs-comment">// ["red", "blue", "green", "2"]</span>instance1.colors.push(<span class="hljs-string">"3"</span>); <span class="hljs-comment">// ["red", "blue", "green", "3"]</span></code></pre><p><strong>这是最成熟的方法，也是现在库实现的方法</strong></p><h3 id="7、混入继承多个对象"><a href="#7、混入继承多个对象" class="headerlink" title="7、混入继承多个对象"></a>7、混入继承多个对象</h3><p>混元（Mix-ins），任意多数量的对象中复制属性，然后将它们混在一起组成一个新对象</p><pre><code class="hljs javascript"><span class="hljs-comment">// 混合其它 </span><span class="hljs-built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</code></pre><p>Object.assign会把 OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p><h3 id="8、ES6类继承extends"><a href="#8、ES6类继承extends" class="headerlink" title="8、ES6类继承extends"></a>8、ES6类继承extends</h3><p>复制属性继承-浅拷贝，深拷贝-extend</p><h2 id="问几个问题"><a href="#问几个问题" class="headerlink" title="问几个问题"></a>问几个问题</h2><h3 id="Q1-函数声明和类声明的区别？"><a href="#Q1-函数声明和类声明的区别？" class="headerlink" title="Q1:函数声明和类声明的区别？"></a><strong>Q1:函数声明和类声明的区别？</strong></h3><p>函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。</p><h3 id="Q2-ES5继承和ES6继承的区别？"><a href="#Q2-ES5继承和ES6继承的区别？" class="headerlink" title="Q2:ES5继承和ES6继承的区别？"></a><strong>Q2:ES5继承和ES6继承的区别？</strong></h3><ul><li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li><li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li></ul><h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><ul><li><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener"><strong>《JavaScript高级程序设计(第3版)》</strong></a></li><li><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener"><strong>冴羽JavaScript深入系列15篇</strong></a></li><li><a href="https://www.muyiy.cn/blog/5/5.1.html" target="_blank" rel="noopener"><strong>木易杨前端进阶-第 5 期：原型 Prototype</strong></a></li><li><a href="https://juejin.im/post/5bcb2e295188255c55472db0" target="_blank" rel="noopener"><strong>JavaScript常用八种继承方案</strong></a></li><li><a href="https://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="noopener"><strong>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）</strong></a></li><li><a href="https://www.jianshu.com/p/652991a67186" target="_blank" rel="noopener"><strong>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）</strong></a></li><li><a href="https://www.jianshu.com/p/a4e1e7b6f4f8" target="_blank" rel="noopener"><strong>最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）</strong></a></li><li><a href="https://github.com/jayli/javascript-patterns/blob/master/chapter6.markdown" target="_blank" rel="noopener"><strong>代码复用模式</strong></a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>欢迎纠错，看到会及时修改哒！❤<br>温故而知新，希望我们都可以保持本心，念念不忘，必有回响。</p>]]></content>
    
    
    <categories>
      
      <category>技术blog</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文梳理CSS必会知识点</title>
    <link href="/2020/07/20/technology/css-basic/"/>
    <url>/2020/07/20/technology/css-basic/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要梳理CSS必会知识点，会持续补充更新哦！<br>万字长文预警！这可能是目前最长的一篇了🙈🙉🙊</p></blockquote><h2 id="CSS引入"><a href="#CSS引入" class="headerlink" title="CSS引入"></a>CSS引入</h2><h3 id="有哪些引入方式？通过link和-import引入有什么区别？（-）"><a href="#有哪些引入方式？通过link和-import引入有什么区别？（-）" class="headerlink" title="有哪些引入方式？通过link和@import引入有什么区别？（*）"></a>有哪些引入方式？通过link和@import引入有什么区别？（*）</h3><ul><li><strong>CSS引入方式有4种</strong> 内联、内嵌、外链、导入</li><li><strong>外链 link</strong> 除了可以加载css之外,还可以定义rss、rel等属性，没有兼容性问题，支持使用javascript改变样式</li><li><strong>导入[@import ]</strong> 是css提供的，只能用于加载css，不支持通过javascript修改样式</li><li>页面被加载的时候，link会被同时加载，而@import则需等到页面加载完后再加载，可能出现无样式网页</li></ul><h3 id="Style-标签写在-body-后和-body-前有什么区别？"><a href="#Style-标签写在-body-后和-body-前有什么区别？" class="headerlink" title="Style 标签写在 body 后和 body 前有什么区别？"></a>Style 标签写在 body 后和 body 前有什么区别？</h3><ul><li>一般情况下，页面加载时自上而下的。将style标签至于body之前，为的是先加载样式。</li><li>若是写在body标签之后，由于浏览器以逐行方式对html文档进行解析，当解析到写在写在文档尾部的样式表时，会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后会重新渲染，在windows的IE下可能会出现FOUC现象（页面闪烁）。</li></ul><h3 id="什么是-FOUC-Flash-of-Unstyled-Content-？-如何来避免-FOUC"><a href="#什么是-FOUC-Flash-of-Unstyled-Content-？-如何来避免-FOUC" class="headerlink" title="什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC"></a>什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC</h3><ul><li>当使用@import导入CSS时，会导致某些页面在IE出现奇怪的现象： 没有样式的页面内容显示瞬间闪烁，这种现象被称为“文档样式暂时失效”，简称FOUC。</li><li><strong>产生原因：</strong> 当样式表晚于结构性html加载时，加载到此样式表时，页面将会停止之前的渲染。等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</li><li><strong>解决办法：</strong> 只要在之间加入一个或者元素即可。</li></ul><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p>CSS选择器的解析是从上到下，从右向左解析，为了避免对所有元素进行解析</p><ul><li>可继承的样式：font-size, font-family, color，ul，li，dl，dt，dd；</li><li>不可继承的样式：border, padding, margin, width, height</li></ul><h3 id="CSS选择器种类"><a href="#CSS选择器种类" class="headerlink" title="CSS选择器种类"></a>CSS选择器种类</h3><ul><li>id选择器<ul><li>根据提供的唯一id号快速获取标签对象</li><li>用于充当label标签for属性的值：用户名：，表示单击此label标签时，id为userid的标签获得焦点</li></ul></li><li>类选择器 (class )</li><li>标签选择器 (h1)</li><li>相邻选择器<ul><li>直接相邻元素选择器  (h1+p)</li><li>普通相邻元素选择器 （h2 ~ h2）</li></ul></li><li>子选择器(ul&gt;li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li><li>属性选择器（a[rel = “XXX”]）</li><li>伪类选择器( :hover :first-child ···)</li><li>伪元素选择器( :before :after ···)</li><li>分组选择器</li></ul><h3 id="CSS选择器优先级"><a href="#CSS选择器优先级" class="headerlink" title="CSS选择器优先级"></a>CSS选择器优先级</h3><ul><li><strong>优先级由高到低</strong><br>  !important &gt; 内联style &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器&gt;继承</li><li><strong>优先级算法(权重)</strong><ul><li>元素选择符的权值<ul><li>元素标签（派生选择器）：1</li><li>class选择符：10</li><li>id选择符：100</li><li>内联样式最大：1000</li></ul></li><li>继承得到的样式的优先级最低</li><li>比较多个权重相同的CSS选择器优先级，定义的位置决定一切。从位置上由高到低分为六级：<pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 位于&lt;head/&gt;标签里的&lt;style/&gt;中所定义的CSS拥有最高级的优先权。<span class="hljs-number">2.</span> 位于 &lt;style/&gt;标签中的 @<span class="hljs-keyword">import</span> 引入样式表所定义。<span class="hljs-number">3.</span> 由&lt;link/&gt;标签所引入的样式表定义。<span class="hljs-number">4.</span> 由&lt;link/&gt;标签所引入的样式表内的 @<span class="hljs-keyword">import</span> 导入样式表定义。<span class="hljs-number">5.</span> 用户设定。<span class="hljs-number">6.</span> 浏览器默认。</code></pre></li></ul></li></ul><ul><li>同位置情况下样式定义最近者为准（优先级相同，选择最后出现的样式）<h2 id="CSS伪类和伪元素"><a href="#CSS伪类和伪元素" class="headerlink" title="CSS伪类和伪元素"></a>CSS伪类和伪元素</h2></li></ul><h3 id="CSS伪元素"><a href="#CSS伪元素" class="headerlink" title="CSS伪元素"></a>CSS伪元素</h3><ul><li><strong>::selection</strong> 选择被用户选取的元素部分</li><li><strong>:first-line</strong> 选择元素中的第一行</li><li><strong>:first-letter</strong> 选择元素中的第一个字符</li><li><strong>:after</strong> 在元素在该元素之后添加内容</li><li><strong>:before</strong> 在元素在该元素之前添加内容</li></ul><h3 id="CSS伪类"><a href="#CSS伪类" class="headerlink" title="CSS伪类"></a>CSS伪类</h3><ul><li><strong>:root</strong> 选择文档的根元素，等同于html元素</li><li><strong>:empty</strong> 选择没有子元素的元素</li><li><strong>:target</strong> 选取当前活动的目标元素</li><li><strong>:not(selector)</strong> 选择除 selector 元素意外的元素</li><li><strong>:enabled</strong> 选择可用的表单元素</li><li><strong>:disabled</strong> 选择禁用的表单元素</li><li><strong>:checked</strong> 选择被选中的表单元素</li><li><strong>:first-child</strong> 选取当前选择器下第一个元素。</li><li><strong>:last-child</strong> 和 first-child 相反，选取当前选择器下最后一个元素。</li><li><strong>:only-child</strong> 选取唯一子元素。如果一个元素的父元素只有它一个子元素，这个伪类就会生效。如果一个元素还有兄弟元素，这个伪类就不会对它生效。</li><li><strong>:only-of-type</strong> 选取唯一的某个类型的元素。如果一个元素的父元素里只有它一个当前类型的元素，这个伪类就会生效。这个伪类允许父元素里有其他元素，只要不和自己一样就可以。</li></ul><h4 id="静态伪类（只用于a标签）"><a href="#静态伪类（只用于a标签）" class="headerlink" title="静态伪类（只用于a标签）"></a>静态伪类（只用于a标签）</h4><ul><li>:link 指示这个“超链接”（即 a 元素里有一个 href 属性）未被访问</li><li>:visited 指示这个“超链接”已被访问</li></ul><h4 id="动态伪类（使用时鼓励“LVHT”顺序）"><a href="#动态伪类（使用时鼓励“LVHT”顺序）" class="headerlink" title="动态伪类（使用时鼓励“LVHT”顺序）"></a>动态伪类（使用时鼓励“LVHT”顺序）</h4><ul><li>:focus 指示这个元素拥有输入“焦点”——即可以接受键盘输入，或通过某种方式可以激活</li><li>:hover 指示当鼠标停留在这个元素上时，外观可以作相应改变</li><li>:active 指示这个元素可以被用户输入“激活”，如，用户停留在一个超链接上，当点击鼠标时，这个链接就会“激活”</li></ul><h3 id="伪类和伪元素的根本区别"><a href="#伪类和伪元素的根本区别" class="headerlink" title="伪类和伪元素的根本区别"></a>伪类和伪元素的根本区别</h3><ul><li><strong>它们是否创造了新的元素(抽象)</strong>。</li><li>从我们模仿其意义的角度来看，如果需要添加新元素加以标识的，就是伪元素，反之，如果只需要在既有元素上添加类别的，就是伪类。</li><li>伪元素在一个选择器里只能出现一次，并且只能出现在末尾。</li><li>伪类则是像真正的类一样发挥着类的作用，没有数量上的限制，只要不是相互排斥的伪类，也可以同时使用在相同的元素上。</li><li>伪类用一个冒号表示 :first-child，伪元素则使用两个冒号表示 ::first-line(为了向下兼容，现在的浏览器中伪元素选择器用单冒号和双冒号都可以)。</li></ul><h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><h3 id="盒模型分类"><a href="#盒模型分类" class="headerlink" title="盒模型分类"></a>盒模型分类</h3><ul><li>IE盒模型（怪异盒模型）<ul><li>width = border + padding + content</li><li>一个盒子的宽度 = width + margin</li></ul></li><li>W3C盒模型（标准盒模型）<ul><li>width = content</li><li>一个盒子的宽度 = width + padding + border + margin</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542493/1595308434333-edaa744e-b7cf-4497-a5a3-23279762365b.png#align=left&display=inline&height=495&margin=%5Bobject%20Object%5D&originHeight=495&originWidth=843&size=0&status=done&style=none&width=843" srcset="/img/loading.gif" alt=""><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1542493/1595308434349-7e227090-253e-452e-90d7-8929d4826136.png#align=left&display=inline&height=526&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=869&size=0&status=done&style=none&width=869" srcset="/img/loading.gif" alt=""></p><h3 id="转换盒模型"><a href="#转换盒模型" class="headerlink" title="转换盒模型"></a>转换盒模型</h3><p>Css中默认的盒模型是W3C盒模型，两者间的转换可以通过设置属性box-sizing来转换</p><pre><code class="hljs css">box-sizing: content-box; // W3C盒模型标准 box-sizing: border-box; // IE盒模型标准</code></pre><h3 id="盒子一些相关宽度"><a href="#盒子一些相关宽度" class="headerlink" title="盒子一些相关宽度"></a>盒子一些相关宽度</h3><ul><li>clientWidth = width+左右padding</li><li>offsetWidth = width + 左右padding + 左右boder</li><li>scrollWidth：获取指定标签内容层的真实宽度（可视区域宽度+被隐藏区域宽度）</li></ul><h3 id="边界塌陷"><a href="#边界塌陷" class="headerlink" title="边界塌陷"></a>边界塌陷</h3><p>CSS 中存在一个 margin collapse，即边界塌陷或者说边界重叠。<br>只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。</p><h4 id="并排-DIV-边界塌陷（兄弟）"><a href="#并排-DIV-边界塌陷（兄弟）" class="headerlink" title="并排 DIV 边界塌陷（兄弟）"></a>并排 DIV 边界塌陷（兄弟）</h4><p>对于上下两个并排的 DIV 块而言，上面 DIV 的 margin-bottom 和下面 DIV 的 margin-top 会塌陷，会取<strong>上下两者 margin 里最大值作为显示值</strong>，只设置单个margin。</p><h4 id="包含元素盒子塌陷（父子）"><a href="#包含元素盒子塌陷（父子）" class="headerlink" title="包含元素盒子塌陷（父子）"></a>包含元素盒子塌陷（父子）</h4><p>父级div中没有border，padding，inlinecontent，子级div的margin会一直向上找，直到找到某个标签包括border，padding，inline content(文本)中的其中一个，然后按此div 进行margin。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>为父盒子设置border，为外层添加border后父子盒子就不是真正意义上的贴合 （可以设置成透明：border: 1px solid transparent）</li><li>为父盒子添加overflow: hidden;</li><li>为父盒子设定padding值；</li><li>为父盒子添加position：fixed；</li></ul><h3 id="负值作用"><a href="#负值作用" class="headerlink" title="负值作用"></a>负值作用</h3><ul><li>负 marign实现元素的水平垂直居中</li><li>负 marign隐藏列表 li 首尾多余的边框</li><li>负 text-indent 实现文字的隐藏</li><li>负的 z-index 参与层叠上下文排序</li><li>定位中的left、right、top、bottom</li></ul><h2 id="position-定位"><a href="#position-定位" class="headerlink" title="position 定位"></a>position 定位</h2><h3 id="static-普通流定位"><a href="#static-普通流定位" class="headerlink" title="static(普通流定位)"></a>static(普通流定位)</h3><p>默认定位</p><h3 id="relative-相对定位"><a href="#relative-相对定位" class="headerlink" title="relative(相对定位)"></a>relative(相对定位)</h3><ul><li>相对<strong>本元素</strong>的<strong>左上角</strong>进行定位（相对于自身位置进行定位），本元素需要设置position为relative，top、left、bottom、right都可以有值。</li><li>虽然经过定位后，位置可能会移动，但是本元素并<strong>没有脱离文档流</strong>，还占有原来的页面空间。</li></ul><h3 id="absolute-绝对定位"><a href="#absolute-绝对定位" class="headerlink" title="absolute(绝对定位)"></a>absolute(绝对定位)</h3><ul><li>相对于祖代中有relative(相对定位)并且离本元素层级关系上是最近的元素的<strong>左上角</strong>进行定位，如果在祖代元素中没有有relative定位的，就默认相对于body进行定位。</li><li>元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</li><li>绝对定位是<strong>脱离文档流</strong>的，与浮动定位是一样的效果，会压在非定位元素的上方。</li></ul><h3 id="fixed-固定定位"><a href="#fixed-固定定位" class="headerlink" title="fixed(固定定位)"></a>fixed(固定定位)</h3><p>类似于absolute定位，但是是相对于浏览器窗口进行定位</p><h3 id="inherit"><a href="#inherit" class="headerlink" title="inherit"></a>inherit</h3><p>继承父级元素position属性值</p><h3 id="sticky-（额外补充）"><a href="#sticky-（额外补充）" class="headerlink" title="sticky （额外补充）"></a>sticky （额外补充）</h3><p>粘性的-集合了flex和relative,参考<a href="https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/" target="_blank" rel="noopener">杀了个回马枪，还是说说position:sticky吧</a></p><h2 id="float浮动"><a href="#float浮动" class="headerlink" title="float浮动"></a>float浮动</h2><ul><li>有两个取值：left(左浮动)和right(右浮动)。</li><li>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li><li>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3></li></ul><p>最初的优点就是在图文混排的时候可以很好的使文字周围在图片周围。另外当元素浮动了起来之后，它具有块级元素的一些性质例如可以设置宽高等，但它与inline- block还是有一些区别的<br>，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，会造成父级元素高度塌陷为0(<strong>盒子塌陷</strong>)。<br><strong>▲ 注意：设置元素浮动后，该元素的display值会变为block</strong></p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ul><li>盒子大小写死，给每个盒子设定固定的width和height，直到合适为止，非自适应</li><li>父级元素设置高度</li><li>父级元素触发BFC（Float，Overflow: Hidden | Visible，Display: Flex | Grid）<pre><code class="hljs css">&lt;div class="parent" style="overflow:hidden"&gt;         &lt;div class="f"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre></li><li>添加额外标签<pre><code class="hljs css">&lt;div class="parent"&gt;    //添加额外标签并且添加clear属性        &lt;div class="f"&gt;&lt;/div&gt;   &lt;/div&gt;&lt;div style="clear:both"&gt;&lt;/div&gt;</code></pre></li><li><strong>建立伪类选择器清除浮动（推荐）</strong></li></ul><pre><code class="hljs css">//添加:after伪元素<span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">:after</span>&#123;        <span class="hljs-attribute">content</span>: <span class="hljs-string">''</span>; <span class="hljs-comment">/* 设置添加子元素的内容是空 */</span>      <span class="hljs-attribute">display</span>: block; <span class="hljs-comment">/* 设置添加子元素为块级元素 */</span>           <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 设置添加的子元素的高度0 */</span>         <span class="hljs-attribute">visibility</span>: hidden; <span class="hljs-comment">/* 设置添加子元素看不见 */</span>         <span class="hljs-attribute">clear</span>: both; <span class="hljs-comment">/* 设置clear：both */</span>&#125;&lt;div class="parent"&gt;        &lt;div class="f"&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h2 id="display-布局"><a href="#display-布局" class="headerlink" title="display 布局"></a>display 布局</h2><table><thead><tr><th><strong>值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>none</td><td>元素会被隐藏，不显示</td></tr><tr><td>inline</td><td>元素会被设置为内联元素，内部按行从左向右排列（元素前后没有换行符）</td></tr><tr><td>block</td><td>元素会被设置为块级元素，内部按列从上到下排列（元素前后带有换行符）</td></tr><tr><td>inline-block</td><td>元素会被设置为行内块级元素，不会独占一行的块级元素</td></tr><tr><td>list-item</td><td>元素会作为列表显示</td></tr><tr><td>table</td><td>元素会作为块级表格来显示（类似table），表格前后带有换行符</td></tr><tr><td>flex</td><td>元素会进入flex布局模式</td></tr></tbody></table><h3 id="inline、block、inline-block三者区"><a href="#inline、block、inline-block三者区" class="headerlink" title="inline、block、inline-block三者区"></a>inline、block、inline-block三者区</h3><h4 id="block块级特点："><a href="#block块级特点：" class="headerlink" title="block块级特点："></a>block块级特点：</h4><ul><li>每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行）</li><li>元素的高度、宽度、行高以及顶和底边距都可设置。</li><li>元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</li></ul><h4 id="inline内联特点："><a href="#inline内联特点：" class="headerlink" title="inline内联特点："></a>inline内联特点：</h4><ul><li>和其他元素都在一行上；</li><li>元素的高度、宽度及顶部和底部边距不可设置；</li><li>元素的宽度就是它包含的文字或图片的宽度，不可改变。</li></ul><h4 id="inline-block-特点："><a href="#inline-block-特点：" class="headerlink" title="inline-block 特点："></a>inline-block 特点：</h4><ul><li>inline-block内联块状元素同时具备内联元素、块状元素的特点。</li><li>和其他元素都在一行上；</li><li>元素的高度、宽度、行高以及顶和底边距都可设置。</li></ul><h3 id="使用-display-inline-block-会产生什么问题？又如何解决？"><a href="#使用-display-inline-block-会产生什么问题？又如何解决？" class="headerlink" title="使用 display:inline-block 会产生什么问题？又如何解决？"></a>使用 display:inline-block 会产生什么问题？又如何解决？</h3><p>两个inline-block元素放到一起会产生一段空白。</p><h4 id="产生空白的原因"><a href="#产生空白的原因" class="headerlink" title="产生空白的原因"></a>产生空白的原因</h4><p>元素被当成行内元素放置的时候，元素之间的空白符（空格，回车换行等）都会被浏览器处理，根据CSS中空白属性的处理方式（否则是正常，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，空白符较长一定长度，所以inline-block的元素之间就出现了空隙。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ul><li>将子元素标签的结束符和下一个标签的开始符写在同一行或把所有子标签写在同一行</li><li>父元素中设置字体大小：0，在子元素上重置正确的字体大小</li><li>为子元素设置float：left</li></ul><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>该布局提供了一种更高效的方法对容器中的项目进行布局、对齐和分配空间，他没有方向上的限制，可以由开发人员自由操作（子元素的 vertical-align、float、clear 属性会失效）。</p><h3 id="容器属性（6个）"><a href="#容器属性（6个）" class="headerlink" title="容器属性（6个）"></a>容器属性（6个）</h3><ul><li><strong>flex-direction 决定主轴方向（容器排列方向）</strong></li></ul><p>flex-direction: row | row-reverse | column | column-reverse;</p><ul><li><strong>flex-wrap 如果一条轴线排不下，定义换行规则</strong></li></ul><p>flex-wrap: nowrap | wrap | wrap-reverse;</p><ul><li><strong>flex-flow flex-direction和flex-wrap的简写形式</strong></li></ul><p>flex-flow: flex-direction||flex-wrap;</p><ul><li><strong>justify-content 定义容器在主轴上的对齐方式</strong></li></ul><p>justify-content: flex-start | flex-end | center | space-between | space-around;</p><ul><li><strong>align-items 定义容器在交叉轴上的对齐方式</strong></li></ul><p>align-items: flex-start | flex-end | center | baseline | stretch;</p><ul><li><strong>align-content 定义多根轴线的对齐方式，如果容器只有一根轴线，该属性不起作用</strong></li></ul><p>align-content: flex-start | flex-end | center | space-between | space-around |;</p><h3 id="项目属性（6个）"><a href="#项目属性（6个）" class="headerlink" title="项目属性（6个）"></a>项目属性（6个）</h3><ul><li><strong>order</strong> 定义项目的排列顺序，数值越小，排列越靠前，默认为0</li><li><strong>flex-grow</strong> 定义项目的放大比例，默认为0（即如果存在剩余空间，也不放大）</li><li><strong>flex-shrink</strong> 定义项目的缩小比例，默认为1（即如果空间不足，该项目将缩小）</li><li><strong>flex-basis</strong> 定义了在分配多余空间之前，项目占据的主轴空间。默认值为auto（项目本来大小）</li><li><strong>align-self</strong>允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性，默认值为auto（表示继承父元素align-items属性，如果没有父元素，等同于stretch</li></ul><p>align-self: auto | flex-start | flex-end | center | baseline | stretch;</p><ul><li><strong>flex</strong> 是flex-grow、flex-shrink和flex-basis的简写，<strong>默认值为 0 1 auto</strong></li></ul><p>flex: none | [ ‘flex-grow’ ‘flex-shrink’? || ‘flex-basis’]<br>该属性有两个快捷值: <strong>auto(1 1 auto)</strong> 和 <strong>none(0 0 auto)</strong><br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</p><h2 id="overflow溢出"><a href="#overflow溢出" class="headerlink" title="overflow溢出"></a>overflow溢出</h2><ul><li>scroll：必定出现滚动条</li><li>auto：子元素内容大于父元素时出现滚动条</li><li>visible：溢出的内容出现在父元素之外</li><li>hidden：溢出时隐藏</li></ul><h3 id="如何实现：单行文本溢出加-…"><a href="#如何实现：单行文本溢出加-…" class="headerlink" title="如何实现：单行文本溢出加 …(*)"></a>如何实现：单行文本溢出加 …(*)</h3><pre><code class="hljs css"><span class="hljs-selector-tag">white-space</span>: <span class="hljs-selector-tag">nowrap</span>; <span class="hljs-comment">/* 首先，强制文本不换行；*/</span> <span class="hljs-selector-tag">overflow</span>: <span class="hljs-selector-tag">hidden</span>; <span class="hljs-comment">/*其次，隐藏溢出； */</span>  <span class="hljs-selector-tag">text-overflow</span>: <span class="hljs-selector-tag">ellipsis</span>; <span class="hljs-comment">/*最后，对溢出的文本用 ellipsis 省略号代替。 */</span></code></pre><h3 id="全屏滚动的原理？需要哪些css属性？"><a href="#全屏滚动的原理？需要哪些css属性？" class="headerlink" title="全屏滚动的原理？需要哪些css属性？"></a>全屏滚动的原理？需要哪些css属性？</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>类似于轮播图，整体元素一直排列下去，假设有5个需要展示的全屏页面，那么高度将会是500%，但我们只能展示100%，剩下的内容可以通过transform进行Y轴定位，也可以通过margin-top实现</p><h4 id="涉及css属性"><a href="#涉及css属性" class="headerlink" title="涉及css属性"></a>涉及css属性</h4><p>overflow:hidden | transition:all 1000ms ease</p><h2 id="BFC块级格式上下文"><a href="#BFC块级格式上下文" class="headerlink" title="BFC块级格式上下文"></a>BFC块级格式上下文</h2><h3 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h3><ul><li>BFC直译为<strong>块级格式化上下文</strong>，它是一个独立的渲染区域，只有Block-level box参与，它规定了<strong>内部的Block-level Box</strong>如何布局，并且与外部毫不相干。</li><li>W3C对BFC的定义如下：浮动元素和绝对定位元素，非块级盒子的块级容器（例如，内联块，表单元格和表标题），以及溢出值不为“可见”的块级盒子，，都会为他们的内容创建新的BFC（阻止Fromatting上下文，即块级格式文本）。</li><li><strong>注意</strong>：可以把BFC理解为一个大的盒子，其内部是由Block-level box组成的</li></ul><h3 id="如何触发BFC？（-）"><a href="#如何触发BFC？（-）" class="headerlink" title="如何触发BFC？（*）"></a>如何触发BFC？（*）</h3><ul><li>根元素 → 根元素（html）就是最大的BFC</li><li>position设置为 fixed 或者 absolute</li><li>display设置为 inline-block 、table-block 、table-caption</li><li>overflow的值不为visible</li><li>float的值不为none</li></ul><h3 id="BFC布局规则："><a href="#BFC布局规则：" class="headerlink" title="BFC布局规则："></a>BFC布局规则：</h3><ol><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与外部float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ol><h3 id="BFC的作用及原理："><a href="#BFC的作用及原理：" class="headerlink" title="BFC的作用及原理："></a>BFC的作用及原理：</h3><ul><li>自适应两栏布局</li><li>清除内部浮动</li><li>防止垂直 margin 重叠（将垂直方向上的<strong>盒子放在不同的 BFC 中</strong>，margin 就不会重叠了。）</li><li>BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</li></ul><h2 id="IFC行内格式上下文"><a href="#IFC行内格式上下文" class="headerlink" title="IFC行内格式上下文"></a>IFC行内格式上下文</h2><ul><li>内部的盒子一个接着一个地排列，起点是包含块的顶点。</li><li>如果一行放不下内容，那么会被“拆”开放到下一行。</li><li>只有水平方向上的 Margin 会在盒子中保留。</li><li>Padding 和 Border 不会撑开行高。</li></ul><h2 id="z-index层叠上下文"><a href="#z-index层叠上下文" class="headerlink" title="z-index层叠上下文"></a><strong>z-index层叠上下文</strong></h2><ul><li>z-index 可以解决元素之间覆盖顺序的问题，设置它的层叠顺序。</li><li>如果元素是没有定位的，对其设置的 z-index 会是无效的。</li></ul><h3 id="元素层叠时，覆盖关系准则（-）"><a href="#元素层叠时，覆盖关系准则（-）" class="headerlink" title="元素层叠时，覆盖关系准则（*）"></a>元素层叠时，覆盖关系准则（*）</h3><h4 id="同父同级元素"><a href="#同父同级元素" class="headerlink" title="同父同级元素"></a>同父同级元素</h4><ul><li>当具有明显的层叠水平标示时，如识别的z-index值<ul><li>z-index大的覆盖小的，数值越大，越靠近视觉点。</li><li>z-index相同时，在DOM流中处于后面会覆盖前面。</li></ul></li><li>都没有设置 z-index时，使用默认值，一个定位一个没有定位，那么定位覆盖未定位元素。</li><li>都没有定位且发生位置重合现象时，在DOM流中处于后面会覆盖前面。</li></ul><h4 id="父子层级元素"><a href="#父子层级元素" class="headerlink" title="父子层级元素"></a>父子层级元素</h4><ul><li>不同父元素，只要父元素越大，那么整体就越靠近视觉点，而不管其子元素大小情况。</li><li>如果父元素 z-index 有效，那么子元素无论是否设置 z-index 都和父元素一致，会在父元素上方；</li><li>如果父元素 z-index 失效（未定位或者使用默认值），那么定位子元素的 z-index 设置生效。</li></ul><h3 id="层叠上下文的创建"><a href="#层叠上下文的创建" class="headerlink" title="层叠上下文的创建"></a>层叠上下文的创建</h3><h4 id="根层叠上下文"><a href="#根层叠上下文" class="headerlink" title="根层叠上下文"></a>根层叠上下文</h4><p>指的是页面根元素，也就是滚动条的默认的始作俑者元素。这就是为什么，绝对定位元素在left/top等值定位的时候，如果没有其他定位元素限制，会相对浏览器窗口定位的原因。</p><h4 id="定位元素与传统层叠上下文"><a href="#定位元素与传统层叠上下文" class="headerlink" title="定位元素与传统层叠上下文"></a>定位元素与传统层叠上下文</h4><p>对于包含有position:relative/position:absolute/position:fixed的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。</p><h4 id="CSS3与新时代的层叠上下文"><a href="#CSS3与新时代的层叠上下文" class="headerlink" title="CSS3与新时代的层叠上下文"></a>CSS3与新时代的层叠上下文</h4><p>CSS3的出现除了带来了新属性，同时还对过去的很多规则发出了挑战。例如，<a href="https://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/" target="_blank" rel="noopener">CSS3 transform对overflow隐藏对position:fixed定位的影响</a>等。而这里，层叠上下文这一块的影响要更加广泛与显著。<br>如下：</p><ol><li>z-index值不为auto的flex项(父元素display:flex|inline-flex).</li><li>元素的opacity值不是1.</li><li>元素的transform值不是none.</li><li>元素mix-blend-mode值不是normal.</li><li>元素的filter值不是none.</li><li>元素的isolation值是isolate.</li><li>will-change指定的属性值为上面任意一个。</li><li>元素的-webkit-overflow-scrolling设为touch<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1542493/1595308434287-04eee1de-37f7-4b23-be57-941313ac8409.png#align=left&display=inline&height=379&margin=%5Bobject%20Object%5D&originHeight=379&originWidth=581&size=0&status=done&style=none&width=581" srcset="/img/loading.gif" alt=""><h2 id="CSS管理方案"><a href="#CSS管理方案" class="headerlink" title="CSS管理方案"></a>CSS管理方案</h2><h3 id="ITCSS"><a href="#ITCSS" class="headerlink" title="ITCSS"></a>ITCSS</h3>ITCSS（Inverted Triangle CSS）通过规范样式文件的组织结构来适应项目中特殊性不断增加的选择器。见以下倒立的三角形，其中每一层都代表一种样式的概念结构：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1542493/1595308434369-aa0a01b9-9781-4cfd-90af-e21540c8c039.png#align=left&display=inline&height=340&margin=%5Bobject%20Object%5D&originHeight=340&originWidth=551&size=0&status=done&style=none&width=551" srcset="/img/loading.gif" alt=""></li></ol><ul><li>Settings：Global variables、Config switches</li><li>Tools：Mixins、Functions</li><li>Generic：Ground-zero styles（Normalize.css，resets.css）</li><li>Base：Unclassed HTML elements（Type selectors）</li><li>Objects：Cosmetic-free design patterns</li><li>Components：Designed components</li><li>Trumps：Helpers、Overrides</li></ul><p>层级自上而下，选择器影响的 DOM 数量也越来越少，同时选择器特殊性递增。修改某个样式时我们可以轻易从相关组织文件中做出修改，而不影响其它样式，或是导致 CSS 样式继承的崩塌。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1542493/1595308434293-ab33e496-ce77-4896-861a-e0d5c04fd712.png#align=left&display=inline&height=562&margin=%5Bobject%20Object%5D&originHeight=562&originWidth=812&size=0&status=done&style=none&width=812" srcset="/img/loading.gif" alt=""></p><h3 id="命名方案"><a href="#命名方案" class="headerlink" title="命名方案"></a>命名方案</h3><p><strong>解决的主要是命名冲突和复用两个问题</strong>，在众多解决方案中，没有绝对的优劣。还是要结合自己的场景来决定。</p><h4 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h4><ul><li>面对对象的规则，主要的原则是两种：分离结构和外观，分离容器和内容。</li><li>分离结构和外观：增加可重复的设计单元，同时去推进产品和ui对这方面的思考，比如下面的css使用时对象模式的命名和模块化规则。</li><li>分离容器和内容：指的是样式的使用不以元素位置唯一匹配，在任何位置你都可以使用这个样式，如果你不适用这个样式，会保持默认的样式。</li></ul><h4 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h4><ul><li>sma和oocss有很多类似之处，但区分的地方有很多，主要是对样式的分类。分别是：基础、布局、模块、状态、主题</li><li>与oocss相比，其实大部分设计思路是一样的，以一个类作为css的作用域（作用域就是两个限制，1 不符合场景时限制禁止使用 2 符合场景时要正确的使用），另外的区别就是针对皮肤和状态的不同书写规则<ul><li><strong>基础</strong>：可以适用于任何位置，我也称全局样式</li><li><strong>布局</strong>：主要是用来实现不同的特色布局，提高布局的复用率，</li><li><strong>模块</strong>：设计中的模块化，可重复使用的一个单元，一般是dom+css的耦合绑定。</li><li><strong>状态</strong>：描述在特定状态下的布局或者模块的特殊化表现，这里我觉得要推荐下《css禅意花园》，在dom结构不变的情况下，可以通过css的皮肤化实现样式的改版。</li><li><strong>主题</strong>：与状态相比更加定制的是，我们会针对有些特殊的模块，进行主题的设置，包括一系列的颜色、尺寸、交互等进行重度设计，参数化设计。</li></ul></li></ul><h4 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h4><p>bem就是块、元素、修饰符的思维去写样式。它不涉及具体的css结构，只是建议你如何命名css。</p><ul><li>块级：所属组件的名称</li><li>元素：元素在组件里的名称</li><li>修饰符：任何与元素修饰相关的类</li></ul><h4 id="Style-Components"><a href="#Style-Components" class="headerlink" title="Style-Components"></a>Style-Components</h4><p>彻底抛弃 CSS，用 JavaScript 写 CSS 规则</p><h4 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h4><p>使用JS编译原生的CSS文件，使其具备模块化的能力</p><h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><ul><li>使用require.js按需加载CSS</li><li>webpack配置CSS的按需加载</li></ul><h2 id="CSS浏览器兼容性"><a href="#CSS浏览器兼容性" class="headerlink" title="CSS浏览器兼容性"></a>CSS浏览器兼容性</h2><h3 id="浏览器CSS样式初始化"><a href="#浏览器CSS样式初始化" class="headerlink" title="浏览器CSS样式初始化"></a><strong>浏览器CSS样式初始化</strong></h3><p>由于每个浏览器的css默认样式不尽相同，所以最简单有效的方式就是对其进行初始化，在所有CSS开始前，先把marin和padding都设为0，以防不同浏览器的显示效果不一样（推荐初始化库Normalize.css）。</p><h3 id="浏览器私有属性"><a href="#浏览器私有属性" class="headerlink" title="浏览器私有属性"></a><strong>浏览器私有属性</strong></h3><ul><li>我们经常会在某个CSS的属性前添加一些前缀，比如-webkit-，-moz- ，-ms-，这些就是浏览器的私有属性，出现私有属性的原因是制定HTML和CSS标准的组织W3C动作是很慢的。</li><li>通常，有W3C组织成员提出一个新属性，比如说圆角border-radius，大家都觉得好，但W3C制定标准，要走很复杂的程序，审查等。而浏览器商市场推广时间紧，如果一个属性已经够成熟了，就会在浏览器中加入支持。</li></ul><p>为避免日后W3C公布标准时有所变更，会加入一个私有前缀，比如-webkit-border-radius，通过这种方式来提前支持新属性。等到日后W3C公布了标准，border-radius的标准写法确立之后，再让新版的浏览器支持border-radius这种写法。常用的前缀有：</p><ul><li>-moz代表firefox浏览器私有属性</li><li>-ms代表IE浏览器私有属性</li><li>-webkit代表chrome、safari私有属性</li><li>-o代表opera私有属性</li></ul><p><strong>对于私有属性的顺序要注意，把标准写法放到最后，兼容性写法放到前面</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">-webkit-transform</span><span class="hljs-selector-pseudo">:rotate(-3deg)</span>; <span class="hljs-comment">/*为Chrome/Safari*/</span> <span class="hljs-selector-tag">-moz-transform</span><span class="hljs-selector-pseudo">:rotate(-3deg)</span>; <span class="hljs-comment">/*为Firefox*/</span> <span class="hljs-selector-tag">-ms-transform</span><span class="hljs-selector-pseudo">:rotate(-3deg)</span>; <span class="hljs-comment">/*为IE*/</span> <span class="hljs-selector-tag">-o-transform</span><span class="hljs-selector-pseudo">:rotate(-3deg)</span>; <span class="hljs-comment">/*为Opera*/</span> <span class="hljs-selector-tag">transform</span><span class="hljs-selector-pseudo">:rotate(-3deg)</span>;</code></pre><h3 id="CSS-hack"><a href="#CSS-hack" class="headerlink" title="CSS hack"></a><strong>CSS hack</strong></h3><p>有时我们需要针对不同的浏览器或不同版本写特定的CSS样式，这种针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack，写法大致归纳为3种：条件hack、属性级hack、选择符级hack。</p><h3 id="自动化插件"><a href="#自动化插件" class="headerlink" title="自动化插件"></a><strong>自动化插件</strong></h3><ul><li>Autoprefixer是一款自动管理浏览器前缀的插件，它可以解析CSS文件并且添加浏览器前缀到CSS内容里，使用Can I Use（caniuse网站）的数据来决定哪些前缀是需要的。</li><li>把Autoprefixer添加到资源构建工具（例如Grunt）后，可以完全忘记有关CSS前缀的东西，只需按照最新的W3C规范来正常书写CSS即可。如果项目需要支持旧版浏览器，可修改browsers参数设置 。</li><li>目前webpack、gulp、grunt都有相应的插件，别再让CSS兼容性浪费你的时间。</li></ul><h3 id="常见的CSS兼容性问题有哪些"><a href="#常见的CSS兼容性问题有哪些" class="headerlink" title="常见的CSS兼容性问题有哪些"></a><strong>常见的CSS兼容性问题有哪些</strong></h3><ul><li>不同浏览器的标签默认的padding/margin不同，通过初始化css样式可以解决    *{ margin:0;padding:0px;  }</li><li>IE6双边距BUG</li><li>设置较小高度标签（一般小于10px）在IE6,IE7中高度超出自己设置的高度 ，通过设置overflow:hidden;或者设置行高line-height小于你设置的高度</li><li>IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性</li><li>Chrome中文界面下默认会将小于12px的文本强制为12px    通过加入css属性 -webkit-text-size-adjust：none;可以解决，或者使用transform中的缩放属性</li><li>超链接访问过后hover样式就不出现，因为被点击访问过的超链接样式不再具有hover和active了 ，解决方法是改变css属性的排列属性：L-V-H-A    a:link{} → a:visited{} → a:hover{} → a:active{}</li><li>IE下，event对象有x,y属性，但是没有pageX，pageY属性，但没有x，y属性    解决方式：通过条件- png24位的图片在IE6浏览器上出现背景，解决方案是做出PNG8</li></ul><h2 id="CSS优化及性能提升"><a href="#CSS优化及性能提升" class="headerlink" title="CSS优化及性能提升"></a>CSS优化及性能提升</h2><ul><li>将css文件放在页面最上面，多个css可合并，并尽量减少http请求</li><li>避免过渡约束，避免使用后代选择符，链式选择符，多种类型选择符</li><li>避免不必要的命名空间，避免不必要的重复样式，移除空的css规则</li><li>使用具有语义的名字，使用紧凑的语法</li><li>避免使用 !important</li><li>尽可能地精简规则，尽可能合并不同类的重复规则，修复解析错误</li><li>正确使用display属性<ul><li>inline后不应该使用width、height、margin、padding以及float</li><li>inline-block后不应该使用float；block后不应该使用vertical-align</li></ul></li><li>不滥用浮动，遵守盒模型规则</li><li>不滥用web字体，不声明过多font-size，不重复定义h1-h6，不给h1-h6定义过多样式</li><li>值为0时不需要任何单位</li><li>标准化各种浏览器前缀</li></ul><h2 id="WEB标准以及W3C"><a href="#WEB标准以及W3C" class="headerlink" title="WEB标准以及W3C"></a>WEB标准以及W3C</h2><h3 id="对于结构的要求："><a href="#对于结构的要求：" class="headerlink" title="对于结构的要求："></a>对于结构的要求：</h3><p>规范的标签可以提高搜索引擎对页面的抓取效率，对SEO很有帮助</p><ul><li>标签要闭合</li><li>标签字母小写</li><li>标签不允许随意嵌套</li></ul><h3 id="对于CSS和JS来说："><a href="#对于CSS和JS来说：" class="headerlink" title="对于CSS和JS来说："></a>对于CSS和JS来说：</h3><ul><li>尽量使用外链CSS样式表和JS脚本。同时结构，表现和行为分为三块，符合规范。此外，还得提高页面渲染速度，提高用户体验。</li><li>尽量少用行内样式，保证结构和表现分离。标签的id和class等的属性命名要做到见文知意，标签越少，加载越快，用户体验就会越高。同时代码方面也会更易于维护，便于改版。</li><li>不需要变动内容，便可一同打印版本而不需要复制内容，提高网站易用性。</li></ul><h2 id="问几个问题"><a href="#问几个问题" class="headerlink" title="问几个问题"></a>问几个问题</h2><h3 id="Q1-当position跟display、overflow、float这些特性相互叠加后会出现什么情况？"><a href="#Q1-当position跟display、overflow、float这些特性相互叠加后会出现什么情况？" class="headerlink" title="Q1:  当position跟display、overflow、float这些特性相互叠加后会出现什么情况？"></a>Q1:  当position跟display、overflow、float这些特性相互叠加后会出现什么情况？</h3><ul><li>display：规定元素应该生成的框的类型（子元素的排序方式）</li><li>position：规定元素的定位类型</li><li>float：定义元素在哪个方向浮动</li><li>其中，position:absolute / fixed 优先级最高，当position设置为absolute或者fixed时，float失效，display需要调整，float / absolute定位的元素，只能是块元素或表单（block / table）</li></ul><h3 id="Q2：display-none-与-visibility-hidden-的区别是什么？"><a href="#Q2：display-none-与-visibility-hidden-的区别是什么？" class="headerlink" title="Q2：display:none 与 visibility:hidden 的区别是什么？"></a>Q2：display:none 与 visibility:hidden 的区别是什么？</h3><ul><li>display:none  隐藏对应的元素，在文档布局中不再分配空间（导致重排）</li><li>visibility:hidden  隐藏对应的元素，在档布局中保留原来的空间（导致重绘）</li><li>前者会使元素及其后代全部隐藏；后者具有继承性，子代会保持 hidden 的状态，但也可以单独设置为 visibility: visible 进行显示。</li></ul><h3 id="Q3：border-none-与border-0-有什么区别？"><a href="#Q3：border-none-与border-0-有什么区别？" class="headerlink" title="Q3：border:none;与border:0;有什么区别？"></a>Q3：border:none;与border:0;有什么区别？</h3><p><strong>性能差异：</strong></p><ul><li>{border：0;}: 把border设置为0像素，虽然在页面上看不到，但是按border默认值理解，浏览器依然对border-width/border-color进行了渲染，即已经占用内存值；</li><li>{border：none；}被理解为border-style:none。boder:0;比border:none多渲染了一个border-width:0,也就是为什么border:none的性能要比border:0高；</li></ul><p><strong>兼容性差异：</strong></p><ul><li>{border:none;}当border为“none”时似乎对IE6/7无效边框依然存在当border为“0”时，感觉比“none”更有效，所有浏览器都一致把边框隐藏。</li></ul><h3 id="Q4：px-em-REM-有什么区别"><a href="#Q4：px-em-REM-有什么区别" class="headerlink" title="Q4：px | em| REM 有什么区别?"></a>Q4：px | em| REM 有什么区别?</h3><p><strong>PX</strong><br>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br><strong>EM</strong><br>em的值并不是固定的， em会继承父级元素的字体大小。（浏览器body中1em=16px）</p><ul><li>body选择器中声明Font-size=62.5%；</li><li>将你的原来的px数值除以10，然后换上em作为单位；</li><li>重新计算那些被放大的字体的em数值。避免字体大小的重复声明。</li></ul><p><strong>REM（css3新增）</strong><br>使用rem相对的只是HTML根元素。集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。</p><p><strong>EX（不推荐）</strong></p><ul><li>ex 是一个相对长度单位，1ex 被定义为一种给定字体的小写字母 “x” 的高度。因此，这个值会随字体的不同而变化。</li><li>然而，很多浏览器都没有内置 ex 高度值，只是简单的取 em 的值，再取其一半作为 ex 的值。所以，一般不推荐使用 ex 这个长度单位。<br>选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。</li></ul><h3 id="Q5：视口单位-vw、vh、vmin、vmax"><a href="#Q5：视口单位-vw、vh、vmin、vmax" class="headerlink" title="Q5：视口单位 vw、vh、vmin、vmax"></a>Q5：视口单位 vw、vh、vmin、vmax</h3><ul><li><strong>vw</strong> 视口宽度的1/100。</li><li><strong>vh</strong>  视口高度的1/100。</li><li><strong>vmin</strong>  vw 和 vh 中的最小值。</li><li><strong>vmax</strong> vw 和 vh 中的最大值。</li></ul><h3 id="Q6：RGBA-与-opacity-在透明效果上有什么区别？"><a href="#Q6：RGBA-与-opacity-在透明效果上有什么区别？" class="headerlink" title="Q6：RGBA() 与 opacity 在透明效果上有什么区别？"></a>Q6：RGBA() 与 opacity 在透明效果上有什么区别？</h3><ul><li>opacity 作用于元素，以及元素内的所有内容的透明度</li><li>rgba() 只作用于元素的颜色或者背景色（设置rgba透明的元素的子元素不会继承透明效果）</li></ul><h3 id="Q7：png、jpg、-jpeg、-bmp、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？"><a href="#Q7：png、jpg、-jpeg、-bmp、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？" class="headerlink" title="Q7：png、jpg、 jpeg、 bmp、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？"></a>Q7：png、jpg、 jpeg、 bmp、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</h3><ul><li><strong>png</strong>便携式网络图片（Portable Network Graphics）,是一种无损数据压缩位图文件格式。优点是：压缩比高，色彩好。 大多数地方都可以用。</li><li><strong>jpg</strong>是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。</li><li><strong>gif</strong>是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果。</li><li><strong>bmp</strong>的优点： 高质量图片；缺点： 体积太大； 适用场景： windows桌面壁纸；</li><li><strong>webp</strong>格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。</li></ul><h3 id="Q8：隐藏或者透明元素的方法？"><a href="#Q8：隐藏或者透明元素的方法？" class="headerlink" title="Q8：隐藏或者透明元素的方法？"></a>Q8：隐藏或者透明元素的方法？</h3><pre><code class="hljs css">opacity: 0; //1透明度为 0，整体都看不见了； visibility: hidden; //2这个和上边类似； display: none; //3消失，不占用位置； background-color: rgba(0,0,0,0.2); //4只是背景色透明</code></pre><h3 id="Q9：css-sprites是什么？如何使用？"><a href="#Q9：css-sprites是什么？如何使用？" class="headerlink" title="Q9：css sprites是什么？如何使用？"></a>Q9：css sprites是什么？如何使用？</h3><ul><li>CSS sprites（雪碧）的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。</li><li>该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非标签。</li></ul><h3 id="Q10：什么是渐进增强和优雅降级？"><a href="#Q10：什么是渐进增强和优雅降级？" class="headerlink" title="Q10：什么是渐进增强和优雅降级？"></a>Q10：什么是渐进增强和优雅降级？</h3><p><strong>渐进增强</strong></p><ul><li>是指从最基本的可用性出发，在保证站点页面在低级浏览器中 的可用性和可访问性的基础上，逐步增加功能及提高用户体验。</li><li>本质上讲，我们日常的一些开发习惯，例如首先使用标记语言编写页面，然后通过样式表来控制页面 样式等，都属于渐进增强的概念</li><li>其他更为明显的行为包括使用HTML5、CSS3等新技术，针对高级浏览器为页面提高用户体验的丰富程度。</li></ul><p><strong>优雅降级</strong></p><ul><li>是指首先使用最新的技术面向高级浏览器构建最强的功能及用户体验，然后针对低级浏览器的限制，逐步衰减那些无法被支持的功能及体验。</li><li>在我们日常的开 发中，一个典型的平稳退化的例子就是首先针对Chrome编写页面代码，然后修复IE中的异常或针对IE去除那些无法被实现的功能特色</li></ul><p><strong>所以</strong></p><ul><li>这两个概念方法其实早已并存在我们的日常开发工作中了，只是“渐进增强”与“优雅降级”这样的措辞是近些年才开始被普及。</li><li>在我们眼下的HTML5与 CSS3实战中，这两个概念就尤其重要了，怎样保证使用不断变化的新技术来构建在主流浏览器下都具有基本可用性的站点，并针对高级浏览器进行体验提升，是我们在开发过程中需要明确的思路。</li></ul><h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><ul><li><a href="https://juejin.im/post/5b876f86518825431079ddd6" target="_blank" rel="noopener"><strong>彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index</strong></a></li><li><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener"><strong>深入理解CSS中的层叠上下文和层叠顺序</strong></a></li><li><a href="https://zhuanlan.zhihu.com/p/25303493" target="_blank" rel="noopener"><strong>30 分钟学会 Flex 布局</strong></a></li><li><a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/" target="_blank" rel="noopener"><strong>写给自己看的display: flex布局教程</strong></a></li><li><a href="https://www.zhihu.com/question/264372456" target="_blank" rel="noopener"><strong>浏览器将rem转成px时有精度误差怎么办？</strong></a></li><li><a href="https://juejin.im/post/5efa018d6fb9a07e5c1830b1#heading-16" target="_blank" rel="noopener"><strong>CSS 基础拾遗 | 整理了数十万字资料，分享给你这些 CSS 干货</strong></a></li><li><a href="https://juejin.im/post/5ee0cf335188254ec9505381#heading-26" target="_blank" rel="noopener"><strong>css篇–100道近两万字帮你巩固css知识点</strong></a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>欢迎纠错，看到会及时修改哒！❤<br>温故而知新，希望我们都可以保持本心，念念不忘，必有回响。</p>]]></content>
    
    
    <categories>
      
      <category>技术blog</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从头梳理JS基础（一）数据类型及深浅拷贝</title>
    <link href="/2020/07/17/technology/js-basic1/"/>
    <url>/2020/07/17/technology/js-basic1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>这个系列呢，说是博客其实就是笔记哈哈哈哈，感觉上班久了以后很多基础的东西反而不那么扎实了，也是进行一个梳理吧，站在巨人的肩膀上加一些自己的理解【虽然可能我会把自己绕进去，这不重要 🙈】，但我会努力讲明白哒 😘</p><blockquote><p>本文主要梳理JS的基本数据类型和引用数据类型，显隐式转换规则及深浅拷贝，会持续补充更新哦！</p></blockquote><h2 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h2><p>先来看看三种常见的数据存储结构：</p><ul><li>栈：只允许在一段进行插入或者删除操作的线性表，是一种先进后出的数据结构。（基本数据类型）</li><li>队列：队列是一种先进先出（FIFO）的数据结构。（事件循环）</li><li>堆：堆是基于散列算法的数据结构。（引用数据类型）</li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h2><p>基本类型值指的是那些保存在栈内存中的简单数据段，即这种值是完全保存在内存中的一个位置。</p><h3 id="Underfined-类型"><a href="#Underfined-类型" class="headerlink" title="Underfined 类型"></a><strong>Underfined 类型</strong></h3><p>只有一个值，当 var 声明变量但未初始化时，这个值为 underfined（没必要显式设置）<br />对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型，使用其他的操作都会报错。</p><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a><strong>Null 类型</strong></h3><p>只有一个值，空对象指针，当定义的变量将来用于保存对象时，建议初始化为 null 而不是其他值</p><pre><code class="hljs javascript">underfined == <span class="hljs-literal">null</span>  <span class="hljs-comment">//true</span></code></pre><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a><strong>Boolean 类型</strong></h3><p>true 和 false，注意是区分大小写的，也就是说 True 和 False（以及其他混合大小写形式）都不是 Boolean 的值</p><h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><p>我们常用的 if(变量名),表示变量不为 false,””,underfined,0 和 NaN</p><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(underfined) <span class="hljs-comment">//false </span><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">//false </span><span class="hljs-built_in">Boolean</span>(underfined) <span class="hljs-comment">//false</span><span class="hljs-built_in">Boolean</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">//false </span><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">//false </span><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">//false </span><span class="hljs-built_in">Boolean</span>(&#123;&#125;) <span class="hljs-comment">//true</span></code></pre><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a><strong>Number 类型</strong></h3><p>IEEE754 格式来表示整数和浮点数值</p><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>var num=56 //十进制56 var num=070 //八进制56 var num=0x38 //十六进制56</p><ul><li>八进制第一位必须是 0，后面跟八进制序列 0 到 7，如果超出了范围，则忽略前导 0，后面的数值当做十进制解析，例如：089 会被解析为 89。（八进制字面量在严格模式下是无效的，会抛出错误。）<br /></li><li>十六进制前两位必须是 0x 或 0X，后跟十六进制序列 0<del>9、a</del>f（不区分大小写），如果超出了范围，则会报语法错误。<br /></li></ul><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数值精度最高 17 位，计算会产生舍入误差<br />因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致了 0.1 + 0.2 !== 0.3</p><h4 id="正无穷、负无穷"><a href="#正无穷、负无穷" class="headerlink" title="正无穷、负无穷"></a>正无穷、负无穷</h4><p>正数除以 0 返回正无穷(Infinity)，负数除以 0 返回负无穷(-Infinity) JavaScript 提供了 isFinite() 函数，来确定一个数是不是有穷的。例如：</p><pre><code class="hljs javascript"><span class="hljs-built_in">isFinite</span>(<span class="hljs-number">500</span>)         <span class="hljs-comment">// true </span><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">Infinity</span>);   <span class="hljs-comment">// false</span></code></pre><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>NaN(非数值)是一个特殊的数值，用于表示一个本来要返回数值的操作树未返回数值的情况（这样就不会抛出错误了）</p><pre><code class="hljs javascript"><span class="hljs-comment">//NaN及其本身不相等 </span><span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span> <span class="hljs-comment">//false</span></code></pre><p>会出现 NaN 的几种情况：通过isNaN()函数来确定是不是 NaN</p><pre><code class="hljs javascript"><span class="hljs-comment">//isNaN </span><span class="hljs-built_in">isNaN</span>(<span class="hljs-number">0</span>/<span class="hljs-number">0</span>) <span class="hljs-comment">//true </span><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>/<span class="hljs-number">10</span>) <span class="hljs-comment">//true (任何涉及NaN的操作) </span><span class="hljs-built_in">isNaN</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">//false </span><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"blue"</span>) <span class="hljs-comment">//false </span><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">//false(转换为1)</span></code></pre><h4 id="转换规则-1"><a href="#转换规则-1" class="headerlink" title="转换规则"></a>转换规则</h4><pre><code class="hljs javascript"><span class="hljs-comment">//Number() </span><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">//1 </span><span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">//0 </span><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">//0 </span><span class="hljs-built_in">Number</span>(underfined) <span class="hljs-comment">//NaN </span><span class="hljs-built_in">Number</span>(<span class="hljs-string">"0011"</span>) <span class="hljs-comment">//11 </span><span class="hljs-built_in">Number</span>(<span class="hljs-string">"124"</span>) <span class="hljs-comment">//124 </span><span class="hljs-built_in">Number</span>(<span class="hljs-string">""</span>) <span class="hljs-comment">//0 Number("we1") //NaN </span><span class="hljs-comment">//parseInt() </span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">""</span>); <span class="hljs-comment">// NaN </span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"12aa"</span>); <span class="hljs-comment">// 12 </span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"13.8"</span>); <span class="hljs-comment">// 13 </span><span class="hljs-comment">//parseFloat() </span><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">"077.2"</span>)      <span class="hljs-comment">// 77.2 </span><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">"123.11.22"</span>)   <span class="hljs-comment">// 123.11</span></code></pre><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a><strong>String 类型</strong></h3><h4 id="字符字面量（转义序列）"><a href="#字符字面量（转义序列）" class="headerlink" title="字符字面量（转义序列）"></a>字符字面量（转义序列）</h4><p>\n 换行、\t 制表、\b 空格、\r 回车、\f 进纸、\ 斜杠、&#39; 单引号，在用单引号表示的字符串中使用、&quot; 双引号，在用双引号表示的字符串中使用</p><h4 id="转换规则-2"><a href="#转换规则-2" class="headerlink" title="转换规则"></a>转换规则</h4><pre><code class="hljs javascript"><span class="hljs-comment">//toString()方法（undefined 和 null 值没有） </span><span class="hljs-comment">//String() </span><span class="hljs-keyword">var</span> num; <span class="hljs-built_in">String</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">// "20"  如果值有 toString() 方法，则调用该方法（没有参数）并返回相应的结果 </span><span class="hljs-built_in">String</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// "true" </span><span class="hljs-built_in">String</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// "null" (如果值是 null，则返回 "null") </span><span class="hljs-built_in">String</span>(num) <span class="hljs-comment">// "undefined" (如果值是 undefined，则返回 "undefined")</span><span class="hljs-comment">//String()基本包装类型方法</span><span class="hljs-keyword">var</span> str=<span class="hljs-string">'ceshi str'</span>str.length <span class="hljs-comment">//字符串长度</span>str.trim() <span class="hljs-comment">//删除前后所有空格</span>str.replace() <span class="hljs-comment">//替换,默认只替换第一个，如果要全局替换匹配正则设为g</span>str.split() <span class="hljs-comment">//分隔，指定分隔符将一个串拆分为多个串并放入数组</span></code></pre><h3 id="Synbol类型"><a href="#Synbol类型" class="headerlink" title="Synbol类型"></a><strong>Synbol类型</strong></h3><p>Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用，表示独一无二的值。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'a'</span>);<span class="hljs-keyword">let</span> b = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'a'</span>);a===b <span class="hljs-comment">//false</span></code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。<br /></li><li>定义属性的时候只能将Symbol值放在方括号里面，否则属性的键名会当做字符串而不是Symbol值。同理，在访问Symbol属性的时候也不能通过点运算符去访问，点运算符后面总是字符串，不会读取Symbol值作为标识符所指代的值.<br /></li><li>常量的使用Symbol值最大的好处就是其他任何值都不可能有相同的值，用来设计switch语句是一种很好的方式。<br /></li></ul><h3 id="BigInt类型-第3阶段提案-暂且不论"><a href="#BigInt类型-第3阶段提案-暂且不论" class="headerlink" title="BigInt类型(第3阶段提案,暂且不论)"></a><strong>BigInt类型(第3阶段提案,暂且不论)</strong></h3><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a><strong>引用数据类型</strong></h2><p>引用类型值指的是那些保存在堆内存中的对象，所以引用类型的值保存的是一个指针，这个指针指向存储在堆中的一个对象。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值（按引用访问）。</p><ul><li>除了上面的 6 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，有：Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型 等。<br /></li></ul><h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a><strong>Object类型</strong></h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(); <span class="hljs-keyword">var</span> obj = &#123;&#125;;   <span class="hljs-comment">// 优先对象字面量 </span>valueOf() <span class="hljs-comment">//返回对象的字符串、数值或布尔值表示（通常与toString()方法的返回值相同）。</span></code></pre><h3 id="Array类型（-）"><a href="#Array类型（-）" class="headerlink" title="Array类型（*）"></a><strong>Array类型（*）</strong></h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <span class="hljs-keyword">var</span> arr = [];   <span class="hljs-comment">// 优先数组字面量</span></code></pre><h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.isArray() <span class="hljs-comment">//判断是不是数组</span><span class="hljs-built_in">Array</span>.toString() <span class="hljs-comment">//逗号分隔数组为字符串</span><span class="hljs-built_in">Array</span>.join(<span class="hljs-string">','</span>) <span class="hljs-comment">//指定分隔符分隔数组为字符串（默认为逗号）</span></code></pre><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.unshift() <span class="hljs-comment">//开头添加项，return修改后长度</span><span class="hljs-comment">//数组实现类似栈的行为（后进先出）</span><span class="hljs-built_in">Array</span>.push() <span class="hljs-comment">//末尾添加项，return修改后长度</span><span class="hljs-built_in">Array</span>.pop() <span class="hljs-comment">//末尾移除一项，return移除的项</span><span class="hljs-comment">//数组实现类似队列的行为（先进先出）</span><span class="hljs-built_in">Array</span>.push() <span class="hljs-comment">//末尾添加项，return修改后长度</span><span class="hljs-built_in">Array</span>.shift() <span class="hljs-comment">//开头移除一项，return移除的项</span></code></pre><h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.sort() <span class="hljs-comment">//默认升序（先toString()再比较）</span><span class="hljs-built_in">Array</span>.sort(comp) <span class="hljs-comment">//==&gt;comp 为比较函数，可以指定排序效果</span><span class="hljs-keyword">let</span> a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">11</span>,<span class="hljs-number">4</span>,<span class="hljs-number">23</span>]a.sort() <span class="hljs-comment">//[1, 11, 2, 23, 4]</span>a.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b) <span class="hljs-comment">//[1, 2, 4, 11, 23]</span><span class="hljs-built_in">Array</span>.reverse() <span class="hljs-comment">//反转数组顺序</span></code></pre><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.concat() <span class="hljs-comment">//创建副本将参数依次添加到末尾，retrun新数组</span><span class="hljs-built_in">Array</span>.slice() <span class="hljs-comment">//return 从start到end（不包括end）的项</span><span class="hljs-built_in">Array</span>.splice() <span class="hljs-comment">//* return删除项，不删除则为[]</span><span class="hljs-comment">//参数的三种操作(起始位置，删除项数，插入值)</span><span class="hljs-keyword">let</span> a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">11</span>,<span class="hljs-number">4</span>,<span class="hljs-number">23</span>]<span class="hljs-comment">//1.删除</span>a.splice(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">//[1, 11, 4, 23]</span><span class="hljs-comment">//2.插入</span>a.splice(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//[1, 5, 2, 11, 4, 23]</span><span class="hljs-comment">//3.替换</span>a.splice(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">//[1, 5, 11, 4, 23]</span></code></pre><h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.indexOf() <span class="hljs-comment">//从头开始查找项，return项所在位置，没找到为-1（全等比较）</span><span class="hljs-built_in">Array</span>.lastIndexOf() <span class="hljs-comment">//从尾部开始查找项</span></code></pre><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><pre><code class="hljs javascript"><span class="hljs-comment">//不会对原数组进行修改 运行函数的参为（item,index,array）</span><span class="hljs-built_in">Array</span>.filter() <span class="hljs-comment">//过滤，retrun满足条件（为true）的项组成的数组</span><span class="hljs-built_in">Array</span>.foreach() <span class="hljs-comment">//遍历，无return值</span><span class="hljs-built_in">Array</span>.map() <span class="hljs-comment">//映射，return调用结果所组成的数组</span><span class="hljs-built_in">Array</span>.every() <span class="hljs-comment">//当每一项都满足条件时，return true</span><span class="hljs-built_in">Array</span>.some() <span class="hljs-comment">//当存在一项满足条件时，return true</span></code></pre><h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><pre><code class="hljs javascript"><span class="hljs-comment">//不会对原数组进行修改 运行函数的参为（prev,cur,index,array）</span><span class="hljs-built_in">Array</span>.reduce() <span class="hljs-comment">//从前遍历，迭代所有项返回一个最终值</span><span class="hljs-built_in">Array</span>.reduceRight() <span class="hljs-comment">//从后向前遍历</span></code></pre><h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a><strong>Date类型</strong></h3><p>使用UTC（国际协调时间）</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-comment">//不传参，自动获取当前日期和时间 Sun Jul 05 2020 15:20:11 GMT+0800 (中国标准时间)</span><span class="hljs-built_in">Date</span>.now() <span class="hljs-comment">//retrun 调用这个方法时的日期和时间的毫秒数(时间戳) 1593933631402</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2010</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)).toString() <span class="hljs-comment">//Fri Jan 01 2010 00:00:00 GMT+0800 (CST)</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2017</span>, <span class="hljs-number">4</span>, <span class="hljs-number">21</span>)).valueOf() <span class="hljs-comment">//1495296000000</span></code></pre><h3 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a><strong>RegExp类型</strong></h3><p>支持正则表达式（正则的相关规则单独整理）</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a=<span class="hljs-regexp">/pattern/</span>flags<span class="hljs-comment">//pattern 匹配规则</span><span class="hljs-comment">//flags 标志-表明行为 </span><span class="hljs-comment">//g-全局（而非匹配第一个就停止） i-不区分大小写 m-多行（继续向下查下一行）</span>a.exec(str) <span class="hljs-comment">//捕获组，str为待匹配字符串，return 结果Array</span>a.test(str) <span class="hljs-comment">//str为待匹配字符串，若匹配return true</span></code></pre><h3 id="Function类型（-）"><a href="#Function类型（-）" class="headerlink" title="Function类型（*）"></a><strong>Function类型（*）</strong></h3><p>函数没有重载，当函数重名时，取最后一次定义，建议使用函数声明来定义函数。<br /><strong>函数调用优先级</strong>：<br />new 调用 &gt; call、apply、bind 调用 &gt; 对象上的函数调用 &gt; 普通函数调用<br /><strong>函数内部属性</strong>：</p><ul><li>arguments:参数数组<ul><li>arguments.length-传入参的个数，没有传值的命名参数为underfined，arguments不能重写值，但命名参数可以</li><li>递归时，用arguments.callee（指向拥有该对象的函数）来代替函数名，可以消除紧密耦合，但只能用于非严格模式。<br /></li></ul></li><li>this:执行函数对象（全局时为window）</li></ul><h2 id="隐性转换和显性转换"><a href="#隐性转换和显性转换" class="headerlink" title="隐性转换和显性转换"></a><strong>隐性转换和显性转换</strong></h2><h3 id="强制-显性-类型转换"><a href="#强制-显性-类型转换" class="headerlink" title="强制(显性)类型转换"></a>强制(显性)类型转换</h3><p>强制类型转换主要是指通过String、Number和Boolean等构造方法手动转换成对应的字符串、数字和布尔值。</p><h3 id="自动-隐性-类型转换"><a href="#自动-隐性-类型转换" class="headerlink" title="自动(隐性)类型转换"></a>自动(隐性)类型转换</h3><p>自动类型转换就是不需要人为强制的进行转换，js会自动将类型转换为需要的类型，所以该转换操作用户是感觉不到的，因此又称为隐性类型转换</p><h2 id="数据的深浅拷贝"><a href="#数据的深浅拷贝" class="headerlink" title="数据的深浅拷贝"></a>数据的深浅拷贝</h2><ul><li><strong>浅拷贝（Shallow Copy</strong>） 只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性。</li><li><strong>深拷贝(Deep Copy)</strong>不同于浅拷贝，它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性。（两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性）</li></ul><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h3><h4 id="赋值运算符（-）"><a href="#赋值运算符（-）" class="headerlink" title="赋值运算符（=）"></a>赋值运算符（=）</h4><p>只拷贝对象的引用值</p><h4 id="首层拷贝实现"><a href="#首层拷贝实现" class="headerlink" title="首层拷贝实现"></a>首层拷贝实现</h4><p>（只有第一层是深拷贝）</p><pre><code class="hljs javascript"><span class="hljs-comment">//1.Object.assign()</span><span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj1);\\ES6,拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。<span class="hljs-comment">//2.... 展开运算符</span><span class="hljs-keyword">const</span> obj2 = [...obj1];只是对对象的第一层进行深拷贝<span class="hljs-comment">//3.Array.prototype.slice()</span><span class="hljs-keyword">const</span> obj2 = obj1.slice();<span class="hljs-comment">//4.Array.prototype.concat()</span><span class="hljs-keyword">const</span> obj2 = obj1.concat();</code></pre><h4 id="手写一个浅拷贝"><a href="#手写一个浅拷贝" class="headerlink" title="手写一个浅拷贝"></a>手写一个浅拷贝</h4><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowClone</span>(<span class="hljs-params">obj</span>)</span>&#123;    <span class="hljs-keyword">let</span> result=<span class="hljs-built_in">Array</span>.isArray(obj)?[]:&#123;&#125;    <span class="hljs-built_in">Object</span>.keys(obj).forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;        result[element]=obj[element]    &#125;);    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝(*)"></a><strong>深拷贝(*)</strong></h3><h4 id="JSON-parse-和JSON-stringify-（对目标对象有要求）"><a href="#JSON-parse-和JSON-stringify-（对目标对象有要求）" class="headerlink" title="JSON.parse()和JSON.stringify()   （对目标对象有要求）"></a>JSON.parse()和JSON.stringify()   （对目标对象有要求）</h4><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj1));</code></pre><p>缺点：</p><ul><li>undefined、function，正则表达式类型以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时)；</li><li>它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object；</li><li>当出现循环引用时会报错</li></ul><h4 id="递归（真正意义上的深拷贝）"><a href="#递归（真正意义上的深拷贝）" class="headerlink" title="递归（真正意义上的深拷贝）"></a>递归（真正意义上的深拷贝）</h4><p><strong>递归中可能出现的问题：循环引用</strong></p><ul><li>父级引用</li></ul><p>这里的父级引用指的是，当对象的某个属性，正是这个对象本身，此时我们如果进行深拷贝，可能会在子元素-&gt;父对象-&gt;子元素…这个循环中一直进行，导致栈溢出。<br />解决办法:判断一个对象的字段是否引用了这个对象或这个对象的任意父级</p><ul><li>同级引用</li></ul><p>假设对象obj有a,b,c三个子对象，其中子对象c中有个属性d引用了对象obj下面的子对象a。<br />解决办法：父级的引用是一种引用，非父级的引用也是一种引用，那么只要记录下对象A中的所有对象，并与新创建的对象一一对应即可。</p><h4 id="手写一个深拷贝（-）"><a href="#手写一个深拷贝（-）" class="headerlink" title="手写一个深拷贝（*）"></a>手写一个深拷贝（*）</h4><p><strong>已经处理了相关边界及循环引用问题</strong></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">obj</span>) </span>&#123; <span class="hljs-comment">//判断obj是不是一个对象，且当obj为null时原样返回而不是返回｛｝</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span> &amp;&amp; obj != <span class="hljs-literal">null</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj, hash = new WeakMap(</span>)) </span>&#123;  <span class="hljs-comment">//hash用于解决循环引用</span>    <span class="hljs-keyword">if</span> (!isObject(obj)) <span class="hljs-keyword">return</span> obj;    <span class="hljs-keyword">if</span> (hash.has(obj)) <span class="hljs-keyword">return</span> hash.get(obj); <span class="hljs-comment">// 查hash，如果当前obj已经存在则直接取拷贝过的值</span>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">Array</span>.isArray(obj) ? [] : &#123;&#125; <span class="hljs-comment">//对数组和对象进行区分</span>    hash.set(obj, result) <span class="hljs-comment">//obj不存在时存入hash</span>    <span class="hljs-built_in">Object</span>.keys(obj).forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123; <span class="hljs-comment">//遍历obj的key进行拷贝</span>            <span class="hljs-keyword">if</span> (isObject(obj[element])) &#123;                result[element] = deepClone(obj[element], hash) <span class="hljs-comment">//当key对应值仍为对象时，递归拷贝</span>            &#125; <span class="hljs-keyword">else</span> &#123;                result[element] = obj[element] <span class="hljs-comment">//为基本数据类型则直接拷贝</span>            &#125;    &#125;);    <span class="hljs-keyword">return</span> result;&#125;</code></pre><p><strong>拷贝Symbol（）的情况</strong><br />将Object.keys(obj)遍历key值改变为：</p><ul><li>方法一：Object.getOwnPropertySymbols(…)</li><li>方法二：<pre><code class="hljs javascript"><span class="hljs-built_in">Reflect</span>.ownKeys(...)<span class="hljs-comment">//等价于</span><span class="hljs-built_in">Object</span>.getOwnPropertyNames(target).concat(<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(target))</code></pre></li></ul><p><strong>拷贝原型链上数据的情况</strong></p><ul><li>for..in 进行遍历</li></ul><h2 id="问几个问题"><a href="#问几个问题" class="headerlink" title="问几个问题"></a><strong>问几个问题</strong></h2><h3 id="Q1-为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？"><a href="#Q1-为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？" class="headerlink" title="Q1:为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？"></a><strong>Q1:为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？</strong></h3><ul><li>堆比栈大，栈比堆速度快。<br /></li><li>基础数据类型比较稳定，而且相对来说占用的内存小。<br /></li><li>引用数据类型大小是动态的，而且是无限的。<br /></li><li>堆内存是无序存储，可以根据引用直接获取。</li></ul><h3 id="Q2-下面的代码会输出什么？"><a href="#Q2-下面的代码会输出什么？" class="headerlink" title="Q2:下面的代码会输出什么？"></a><strong>Q2:下面的代码会输出什么？</strong></h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'前端开发'</span> &#125;<span class="hljs-keyword">var</span> b = a;a = <span class="hljs-literal">null</span>;<span class="hljs-built_in">console</span>.log(b)</code></pre><blockquote><p>{ name: ‘前端开发’ }    null是基本类型，a = null之后只是把a存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响</p></blockquote><h3 id="Q3-从内存来看-null-和-undefined-本质的区别是什么？"><a href="#Q3-从内存来看-null-和-undefined-本质的区别是什么？" class="headerlink" title="Q3:从内存来看 null 和 undefined 本质的区别是什么？"></a><strong>Q3:</strong>从内存来看 null 和 undefined 本质的区别是什么？</h3><ul><li>给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。</li><li>给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值</li></ul><h3 id="Q4-JS判断一下数据类型？"><a href="#Q4-JS判断一下数据类型？" class="headerlink" title="Q4:JS判断一下数据类型？"></a><strong>Q4:JS判断一下数据类型？</strong></h3><h4 id="typeof-检测基本数据类型的最佳选择"><a href="#typeof-检测基本数据类型的最佳选择" class="headerlink" title="typeof (检测基本数据类型的最佳选择)"></a>typeof (检测基本数据类型的最佳选择)</h4><ul><li>对于基本类型，除 null 以外，均可以返回正确的结果。<br /></li><li>对于引用类型，除 function 以外，一律返回 object。<br /></li><li>对于 null ，返回 object。<br /></li><li>对于 function 返回 function。<br /></li></ul><h4 id="instanceof-判断-A-是否为-B-的实例"><a href="#instanceof-判断-A-是否为-B-的实例" class="headerlink" title="instanceof (判断 A 是否为 B 的实例)"></a>instanceof (判断 A 是否为 B 的实例)</h4><ul><li>A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false<br /></li><li>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型，不同环境下不是同一个构造函数<br /></li><li>Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建<br /></li></ul><h4 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor (构造函数)"></a>constructor (构造函数)</h4><pre><code class="hljs javascript">[ ].constructor == <span class="hljs-built_in">Array</span>   <span class="hljs-literal">true</span>   <span class="hljs-string">" "</span>.constructor == <span class="hljs-built_in">String</span>   <span class="hljs-literal">true</span></code></pre><ul><li>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。<br /></li><li>使用它是不安全的，因为contructor的指向是可以改变的<br/></li></ul><h4 id="使用Object-prototype-toString-call-目前最优解"><a href="#使用Object-prototype-toString-call-目前最优解" class="headerlink" title="使用Object.prototype.toString.call(目前最优解)"></a>使用Object.prototype.toString.call(目前最优解)</h4><p>能够生成固定的返回格式，进行截取得到数据类型，目前基本和引用类型全部支持</p><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">'111'</span>)        <span class="hljs-string">"[object String]"</span></code></pre><h4 id="想了两种取type的方法"><a href="#想了两种取type的方法" class="headerlink" title="想了两种取type的方法"></a>想了两种取type的方法</h4><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> type = <span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">'111'</span>) <span class="hljs-keyword">let</span> name = type.slice(<span class="hljs-number">8</span>,<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">'111'</span>).length<span class="hljs-number">-1</span>)<span class="hljs-comment">//截取 </span><span class="hljs-keyword">let</span> name = type.match(<span class="hljs-regexp">/^\[object (\w+)\]$/</span>)[<span class="hljs-number">1</span>]<span class="hljs-comment">//正则</span></code></pre><h3 id="Q5-什么样的数据值在判断时会被转换为false？"><a href="#Q5-什么样的数据值在判断时会被转换为false？" class="headerlink" title="Q5:什么样的数据值在判断时会被转换为false？"></a><strong>Q5:什么样的数据值在判断时会被转换为false？</strong></h3><p>我们使用 Boolean 函数将类型转换成布尔类型，在 JavaScript 中，只有 6 种值可以被转换成 false，其他都会被转换成 true。</p><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>()) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(+<span class="hljs-number">0</span>)) <span class="hljs-comment">// false  </span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">-0</span>)) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>)) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">""</span>)) <span class="hljs-comment">// false</span></code></pre><h3 id="Q6-函数中的arguments是数组吗？若不是，如何将它转化为真正的数组？"><a href="#Q6-函数中的arguments是数组吗？若不是，如何将它转化为真正的数组？" class="headerlink" title="Q6:函数中的arguments是数组吗？若不是，如何将它转化为真正的数组？"></a><strong>Q6:函数中的arguments是数组吗？若不是，如何将它转化为真正的数组？</strong></h3><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>==<span class="hljs-string">"object"</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">arguments</span>)==<span class="hljs-string">"[object Arguments]"</span></code></pre><p>不是，是类数组对象</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arrayLike = &#123;<span class="hljs-number">0</span>: <span class="hljs-string">'name'</span>, <span class="hljs-number">1</span>: <span class="hljs-string">'age'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'sex'</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">3</span> &#125;     <span class="hljs-comment">// 1. slice     </span><span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike); <span class="hljs-comment">// ["name", "age", "sex"]     </span><span class="hljs-comment">// 2. splice     </span><span class="hljs-built_in">Array</span>.prototype.splice.call(arrayLike, <span class="hljs-number">0</span>); <span class="hljs-comment">// ["name", "age", "sex"]      </span><span class="hljs-comment">// 3. ES6 Array.from     </span><span class="hljs-built_in">Array</span>.from(arrayLike); <span class="hljs-comment">// ["name", "age", "sex"]      </span><span class="hljs-comment">// 4. apply     </span><span class="hljs-built_in">Array</span>.prototype.concat.apply([], arrayLike) <span class="hljs-comment">// ["name", "age", "sex"]   </span><span class="hljs-comment">// 5. ES6扩展运算符     </span>[...arrayLike] <span class="hljs-comment">// ["name", "age", "sex"]</span></code></pre><h3 id="Q7-函数传参数是按值还是引用-数据类型或者对象类型都一样吗？"><a href="#Q7-函数传参数是按值还是引用-数据类型或者对象类型都一样吗？" class="headerlink" title="Q7:函数传参数是按值还是引用?数据类型或者对象类型都一样吗？"></a><strong>Q7:函数传参数是按值还是引用?数据类型或者对象类型都一样吗？</strong></h3><p>ECMAScript中所有函数的参数都是按<strong>值</strong>来传递的，把函数外部的值复制给函数内部的参数，函数只能操作对象的属性和值，而不能操作对象本身。</p><ul><li>原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响，这个很好理解，不再赘述。</li><li>引用值：对象变量里面的值是这个对象在堆内存中的内存地址，因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。</li></ul><h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a><strong>巨人的肩膀</strong></h2><ul><li><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener"><strong>《JavaScript高级程序设计(第3版)》</strong></a><br /></li><li><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener"><strong>《ECMAScript 6 入门》</strong></a></li><li><a href="https://juejin.im/post/5e7d7670f265da797f4afa84" target="_blank" rel="noopener"><strong>JavaScript深入之头疼的类型转换(上)</strong></a></li><li><a href="https://segmentfault.com/a/1190000015042902" target="_blank" rel="noopener"><strong>「JavaScript」带你彻底搞清楚深拷贝、浅拷贝和循环引用</strong></a></li><li><a href="https://github.com/axuebin/articles/issues/20" target="_blank" rel="noopener"><strong>JavaScript基础心法——深浅拷贝</strong></a></li><li><a href="https://muyiy.cn/blog/4/4.1.html" target="_blank" rel="noopener"><strong>木易杨前端进阶-第 4 期：深浅拷贝原理</strong></a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>欢迎纠错，看到会及时修改哒！❤<br>温故而知新，希望我们都可以保持本心，念念不忘，必有回响。</p>]]></content>
    
    
    <categories>
      
      <category>技术blog</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从头梳理JS基础（二）函数执行的整个过程</title>
    <link href="/2020/07/14/technology/js-basic2/"/>
    <url>/2020/07/14/technology/js-basic2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要梳理JS 函数执行的整个过程，包括执行上下文，作用域链，内存空间，闭包，this指向和call，apply，bind等，会持续补充更新哦！</p></blockquote><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>评估和执行 JavaScript 代码的环境的抽象概念。</p><ul><li><strong>全局执行上下文</strong>— 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中（一个程序中只会有一个全局执行上下文）。</li><li><strong>函数执行上下文</strong> — 每当一个函数被<strong>调用</strong>时, 都会为该函数创建一个新的上下文（函数上下文可以有任意多个）。每当一个新的执行上下文被创建，它会按定义的顺序执行一系列步骤。</li><li><strong>Eval 函数执行上下文</strong> — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，暂不讨论。</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/13/173480fd15e28686?w=1000&h=290&f=webp&s=11070" srcset="/img/loading.gif" alt=""></p><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><h4 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h4><ul><li><strong>生成变量对象</strong>：全局对象（浏览器的情况下为window ）</li><li><strong>建立作用域链：</strong>全局对象</li><li><strong>确定this指向：</strong>设置** this **的值等于全局对象（var === this. === winodw.）</li></ul><h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><ul><li><strong>生成变量对象</strong>：用活动对象(activation object, AO)来表示变量对象（活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化）。</li><li><strong>建立作用域链：</strong><ul><li>函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中。</li><li>当函数激活时，进入函数上下文，创建 VO/AO后，就会将活动对象添加到作用链的前端。</li><li>Scope (作用域链）= [AO].concat([[Scope]]);</li></ul></li><li><strong>确定this指向：</strong>this 永远指向最后<strong>调用</strong>它的那个对象（参见后文）</li></ul><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><h4 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h4><p>这时候还没有执行代码，<strong>变量对象</strong>会加入：</p><ul><li>函数的所有形参 (如果是函数上下文)<ul><li>由<strong>名称和对应值</strong>组成的一个变量对象的属性被创建</li><li>没有<strong>实参</strong>，属性值设为** undefined**</li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在<strong>相同名称</strong>的属性，则<strong>完全替换</strong>这个属性</li></ul></li><li>变量声明<ul><li>由<strong>名称和对应值（undefined）</strong>组成一个变量对象的属性被创建（var）；</li><li>如果<strong>变量名称</strong>跟已经声明的<strong>形参</strong>或<strong>函数</strong>相同，则变量声明不会干扰已经存在的这类属性</li><li><strong>变量声明提升</strong>:可以在声明之前访问 var 定义的变量（虽然是 undefined），但是在声明之前访问 let 和 const 的变量会得到一个引用错误（未初始化）。</li></ul></li></ul><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><ul><li>顺序执行代码，根据代码，修改变量对象的值</li></ul><h3 id="总结一下函数执行上下文的整个过程"><a href="#总结一下函数执行上下文的整个过程" class="headerlink" title="总结一下函数执行上下文的整个过程"></a>总结一下函数执行上下文的整个过程</h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">"global scope"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> scope2 = <span class="hljs-string">'local scope'</span>;    <span class="hljs-keyword">return</span> scope2;&#125;checkscope();</code></pre><p>执行过程如下：</p><ol><li>checkscope 函数被创建，保存作用域链到 内部属性[[scope]]</li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</li><li>checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</li><li>第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</li><li>第三步：将活动对象压入 checkscope 作用域链顶端</li><li>准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</li><li>查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</li></ol><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>存储代码运行时创建的所有执行上下文。</p><ul><li>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</li><li>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</li></ul><h2 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h2><ul><li>作用域是指程序源代码中定义变量的区域。</li><li>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</li><li>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</li></ul><h3 id="静态和动态作用域"><a href="#静态和动态作用域" class="headerlink" title="静态和动态作用域"></a>静态和动态作用域</h3><ul><li>词法作用域，<strong>函数的作用域在函数定义的时候就决定了</strong>。</li><li>动态作用域，函数的作用域是在函数调用的时候才决定的。</li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul><li>当查找变量的时候，会先从当前上下文的变量对象中查找。</li><li>如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。</li><li>这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</li><li>作用域链和原型继承查找时的区别：如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回<strong>undefined</strong>；但查找的属性在作用域链中不存在的话就会抛出<strong>ReferenceError</strong>。</li></ul><h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p>JS内存空间分为<strong>栈(stack)</strong>、<strong>堆(heap)</strong>、<strong>池(一般也会归类为栈中)</strong>。 其中<strong>栈</strong>存放变量，<strong>堆</strong>存放复杂对象，<strong>池</strong>存放常量，所以也叫常量池。</p><h3 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h3><ul><li>1、分配你所需要的内存</li><li>2、使用分配到的内存（读、写）</li><li>3、不需要时将其释放、归还</li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>JS有自动垃圾收集机制，常用<strong>标记清除</strong>算法来找到哪些对象是不再继续使用的，当将变量设为null时释放引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。</p><ul><li><strong>局部变量</strong>：局部作用域中，函数执行完毕，局部变量没有存在意义，垃圾收集器很容易做出判断并回收。</li><li><strong>全局变量</strong>：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量<strong>避免</strong>使用全局变量。</li></ul><h4 id="常见垃圾回收算法"><a href="#常见垃圾回收算法" class="headerlink" title="常见垃圾回收算法"></a>常见垃圾回收算法</h4><ul><li>引用计数（现代浏览器不再使用）：<ul><li>看一个对象是否有指向它的<strong>引用</strong>。如果没有其他对象指向它了，说明该对象已经不再需要了。</li><li><strong>循环引用：</strong>如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。</li></ul></li><li>标记清除（常用）：<ul><li>从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，<strong>保留</strong>。那些从根部出发无法触及到的对象被标记为<strong>不再使用</strong>，稍后进行回收。</li><li>无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。</li></ul></li></ul><h3 id="常见的内存泄漏"><a href="#常见的内存泄漏" class="headerlink" title="常见的内存泄漏"></a>常见的内存泄漏</h3><h4 id="1、意外的全局变量"><a href="#1、意外的全局变量" class="headerlink" title="1、意外的全局变量"></a>1、意外的全局变量</h4><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg</span>) </span>&#123;    a = <span class="hljs-string">"this is a hidden global variable"</span>; <span class="hljs-comment">//未使用var定义</span>    <span class="hljs-keyword">this</span>.b = <span class="hljs-string">"potential accidental global"</span>; <span class="hljs-comment">//this指向全局</span>&#125;</code></pre><p><strong>解决方法</strong>：<br />在 JavaScript 文件头部加上 <code>&#39;use strict&#39;</code>，使用严格模式避免意外的全局变量，此时<strong>上例中的this指向<code>undefined</code></strong>。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。</p><h4 id="2、被遗忘的计时器或回调函数"><a href="#2、被遗忘的计时器或回调函数" class="headerlink" title="2、被遗忘的计时器或回调函数"></a>2、被遗忘的计时器或回调函数</h4><ul><li>必须手动终止定时器</li><li>现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用 removeEventListener 了。</li></ul><h4 id="3、脱离-DOM-的引用"><a href="#3、脱离-DOM-的引用" class="headerlink" title="3、脱离 DOM 的引用"></a>3、脱离 DOM 的引用</h4><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。那么将来需要把两个引用都清除。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>闭包是一个可以访问外部作用域的内部函数，即使这个外部作用域已经执行结束。闭包的外部作用域是在其<strong>定义</strong>的时候已决定，而不是执行的时候。</li><li>闭包中的变量并不保存中栈内存中，而是保存在堆内存中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量，这些被引用的变量直到闭包被销毁时才会被销毁。</li><li>闭包使得 timer 定时器，事件处理，AJAX 请求等异步任务更加容易，可以通过闭包来达到封装性。</li><li><strong>能不能访问关键看在哪里定义**</strong>，而不是在哪里调用，<strong><strong>调用方法的时候，会跳转到定义方法时候的环境里，而不是调用方法的那一行代码所在的</strong></strong>环境。**</li><li>闭包引起的内存泄露那都是因为浏览器的gc问题(IE8以下为首)导致的，跟js本身没有关系，所以，请不要再问js闭包会不会引发内存泄露了</li><li>闭包只存储外部变量的引用，而不会拷贝这些外部变量的值。var 只有函数作用域  let，coast有函数作用域和块作用域。</li></ul><h4 id="问一个问题"><a href="#问一个问题" class="headerlink" title="问一个问题"></a>问一个问题</h4><p>下面的两段代码中，<strong>checkscope()</strong>执行完成后，闭包<strong>f</strong>所引用的自由变量<strong>scope</strong>会被垃圾回收吗？为什么？</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">"global scope"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">"local scope"</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> scope;    &#125;    <span class="hljs-keyword">return</span> f;&#125;checkscope()();</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">"global scope"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">"local scope"</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> scope;    &#125;    <span class="hljs-keyword">return</span> f;&#125;<span class="hljs-keyword">var</span> foo = checkscope(); foo();</code></pre><blockquote><p>第一段中自由变量特定时间之后回收：执行完毕后出栈，该对象没有绑定给谁，从Root开始查找无法可达，此活动对象一段时间后会被回收<br>第二段中自由变量不回收：此对象赋值给 <strong>var foo = checkscope();</strong>，将foo压入栈中，foo指向堆中的f活动对象,对于Root来说可达，不会被回收。</p></blockquote><p><strong>如果想让第二段中自由变量回收，要怎么办？</strong><br /><strong>foo = null;</strong>，把引用断开就可以了。</p><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p><strong>this 永远指向 最后调用它的那个对象</strong> <br />this的值不会被保存在作用域链中，this的值取决于函数被调用的时候的情景（也就是执行上下文被创建时确定的）。<br /></p><h3 id="判断函数上下文中this的绑定对象"><a href="#判断函数上下文中this的绑定对象" class="headerlink" title="判断函数上下文中this的绑定对象"></a>判断函数上下文中this的绑定对象</h3><ul><li>new绑定：作为一个构造函数，this绑定到<strong>新创建的对象</strong>，注意：显示return函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。</li><li>显示绑定（call，apply，bind)：<ul><li>call()、apply()–this指向绑定的对象上</li><li>bind()–this将永久地被绑定到了bind的第一个参数</li></ul></li><li>隐式绑定：this指向<strong>调用函数的对象，</strong>由上下文对象调用时，绑定到上下文对象</li><li>默认绑定： 非严格模式情况下，this 指向 window(全局变量), 严格模式下，this指向 undefined</li><li>箭头函数–所有的箭头函数都没有自己的this<ul><li>箭头函数不绑定this，箭头函数中的this相当于普通变量。</li><li>箭头函数的this寻值行为与普通变量相同，在作用域中逐级寻找。</li><li>箭头函数的this无法通过bind，call，apply来<strong>直接</strong>修改（可以间接修改）。</li><li>改变作用域中this的指向可以改变箭头函数的this。</li><li>eg. <code>function closure(){()=&gt;{//code }}</code>，在此例中，我们通过改变封包环境<code>closure.bind(another)()</code>，来改变箭头函数this的指向</li></ul></li><li>作为一个DOM事件处理函数–this指向触发事件的元素，也就是始事件处理程序所绑定到的DOM节点。</li><li>立即执行函数(function() {})()中的this指向的window对象，因为完整写法就是window.(function() {})()<blockquote><p><strong>new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</strong></p></blockquote></li></ul><h2 id="call，apply，bind"><a href="#call，apply，bind" class="headerlink" title="call，apply，bind"></a>call，apply，bind</h2><h3 id="call，apply，bind三者之间的区别"><a href="#call，apply，bind三者之间的区别" class="headerlink" title="call，apply，bind三者之间的区别"></a>call，apply，bind三者之间的区别</h3><ul><li>三者都是用来改变函数的this指向</li><li>三者的第一个参数都是this指向的对象</li><li>bind是返回一个绑定函数可稍后执行，call、apply是立即调用</li><li>三者都可以给定参数传递</li><li>call和bind给定参数需要将参数全部列出，apply给定参数数组</li></ul><h3 id="模拟一个call"><a href="#模拟一个call" class="headerlink" title="模拟一个call"></a><strong>模拟一个call</strong></h3><pre><code class="hljs javascript"><span class="hljs-comment">//ES6实现</span><span class="hljs-built_in">Function</span>.prototype.myCall=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)</span>&#123;    context=context || <span class="hljs-built_in">window</span>  <span class="hljs-comment">//当参数为null时指向window</span>    <span class="hljs-keyword">var</span> args=[...arguments].slice(<span class="hljs-number">1</span>)<span class="hljs-comment">//将类数组对象转为数组并截取从1到结尾的参数</span>    <span class="hljs-keyword">var</span> fn = <span class="hljs-built_in">Symbol</span>() <span class="hljs-comment">//设定fn为唯一属性</span>    context[fn]=<span class="hljs-keyword">this</span> <span class="hljs-comment">//fn绑定当前函数</span>    <span class="hljs-keyword">var</span> result=context[fn](...args) <span class="hljs-comment">//传入参并执行函数，考虑有返回值的情况</span>    <span class="hljs-keyword">delete</span> context[fn] <span class="hljs-comment">//删除fn</span>    <span class="hljs-keyword">return</span> result <span class="hljs-comment">//返回return值</span>&#125;<span class="hljs-comment">//ES3实现</span><span class="hljs-built_in">Function</span>.prototype.myCall=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)</span>&#123;    context=context || <span class="hljs-built_in">window</span>    <span class="hljs-keyword">var</span> args=[]    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">arguments</span>.length;i++)&#123; <span class="hljs-comment">//for循环取参数数组</span>        args.push(<span class="hljs-built_in">arguments</span>[i])    &#125;    context.fn=<span class="hljs-keyword">this</span>    <span class="hljs-keyword">var</span> result=<span class="hljs-built_in">eval</span>(<span class="hljs-string">'context.fn('</span>+args+<span class="hljs-string">')'</span>) <span class="hljs-comment">//eval解析参数列表</span>    <span class="hljs-keyword">delete</span> context.fn    <span class="hljs-keyword">return</span> result&#125;</code></pre><h3 id="模拟一个apply"><a href="#模拟一个apply" class="headerlink" title="模拟一个apply"></a><strong>模拟一个apply</strong></h3><p><strong>apply和call的区别是call需要列出所有参数，而apply传入一个参数数组</strong></p><pre><code class="hljs javascript"><span class="hljs-comment">//ES6实现</span><span class="hljs-built_in">Function</span>.prototype.myApply=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)</span>&#123;    context=context || <span class="hljs-built_in">window</span>    <span class="hljs-keyword">var</span> args=<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]||[] <span class="hljs-comment">//与call不同的地方是直接传入一个参数数组，获取该数组</span>    <span class="hljs-keyword">var</span> fn = <span class="hljs-built_in">Symbol</span>();    context[fn]=<span class="hljs-keyword">this</span>    <span class="hljs-keyword">var</span> result=context[fn](...args)    <span class="hljs-keyword">delete</span> context[fn]    <span class="hljs-keyword">return</span> result&#125;<span class="hljs-comment">//ES3实现</span><span class="hljs-built_in">Function</span>.prototype.myApply=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)</span>&#123;    context=context || <span class="hljs-built_in">window</span>    <span class="hljs-keyword">var</span> args=<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]||[] <span class="hljs-comment">//与call不同的地方是直接传入一个参数数组，获取该数组</span>    context.fn=<span class="hljs-keyword">this</span>    <span class="hljs-keyword">var</span> result=<span class="hljs-built_in">eval</span>(<span class="hljs-string">'context.fn('</span>+args+<span class="hljs-string">')'</span>)    <span class="hljs-keyword">delete</span> context.fn    <span class="hljs-keyword">return</span> result&#125;</code></pre><h3 id="模拟一个bind"><a href="#模拟一个bind" class="headerlink" title="模拟一个bind"></a><strong>模拟一个bind</strong></h3><ul><li>1、可以指定<code>this</code></li><li>2、返回一个函数</li><li>3、可以传入参数</li><li>4、柯里化<pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);    &#125;    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>    <span class="hljs-keyword">var</span> args1 = [...arguments].slice(<span class="hljs-number">1</span>)    <span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;;    <span class="hljs-keyword">var</span> newContext = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> args2 = [...arguments]        <span class="hljs-keyword">return</span> self.myCall(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> fn ? <span class="hljs-keyword">this</span> : context, ...args1, ...args2);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.prototype) &#123;        fn.prototype = <span class="hljs-keyword">this</span>.prototype    &#125;    newContext.prototype = <span class="hljs-keyword">new</span> fn();    <span class="hljs-keyword">return</span> newContext;&#125;</code></pre><h2 id="疯狂自测一波"><a href="#疯狂自测一波" class="headerlink" title="疯狂自测一波"></a>疯狂自测一波</h2><h3 id="Q1-判断下面两段代码分别输出什么？"><a href="#Q1-判断下面两段代码分别输出什么？" class="headerlink" title="Q1:判断下面两段代码分别输出什么？"></a><strong>Q1:判断下面两段代码分别输出什么？</strong></h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">"global scope"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">"local scope"</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> scope;    &#125;    <span class="hljs-keyword">return</span> f();&#125;checkscope();</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">"global scope"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">"local scope"</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> scope;    &#125;    <span class="hljs-keyword">return</span> f;&#125;checkscope()();</code></pre><blockquote><p>两段代码都会打印：<code>local scope</code>。<br>JavaScript采用的是词法作用域，函数的作用域基于函数<strong>创建</strong>的位置。</p></blockquote></li></ul><h3 id="Q2-下面两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？"><a href="#Q2-下面两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？" class="headerlink" title="Q2:下面两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？"></a><strong>Q2:下面</strong>两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？</h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">"global scope"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">"local scope"</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> scope;    &#125;    <span class="hljs-keyword">return</span> f();&#125;checkscope();</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">"global scope"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">"local scope"</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">return</span> scope;    &#125;    <span class="hljs-keyword">return</span> f;&#125;checkscope()();</code></pre><blockquote><p>执行上下文栈的变化不一样</p></blockquote><pre><code class="hljs javascript"><span class="hljs-comment">//模拟第一段代码：</span>ECStack.push(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">checkscope</span>&gt;</span> functionContext);</span>ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop();//模拟第二段代码：ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop();</code></pre><h3 id="Q3-判断下面两段代码分别输出什么？"><a href="#Q3-判断下面两段代码分别输出什么？" class="headerlink" title="Q3:判断下面两段代码分别输出什么？"></a><strong>Q3:判断下面两段代码分别输出什么？</strong></h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a);    a = <span class="hljs-number">1</span>;&#125;foo();</code></pre><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;    a = <span class="hljs-number">1</span>;    <span class="hljs-built_in">console</span>.log(a);&#125;bar();</code></pre><blockquote><p>第一段会报错：<code>Uncaught ReferenceError: a is not defined</code>( “a” 并没有通过 var 关键字声明，所有不会被存放在 AO 中)<br>第二段会打印：<code>1</code>(执行 console 的时候，全局对象已经被赋予了 a 属性)</p></blockquote><h3 id="Q4-判断下面这段代码输出什么？"><a href="#Q4-判断下面这段代码输出什么？" class="headerlink" title="Q4:判断下面这段代码输出什么？"></a><strong>Q4:判断下面这段代码输出什么？</strong></h3><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(foo);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"foo"</span>);&#125;<span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;</code></pre><blockquote><p>会打印函数，而不是 undefined<br>(如果<strong>变量名称</strong>跟已经声明的<strong>形参</strong>或<strong>函数</strong>相同，则变量声明<strong>不会干扰</strong>已经存在的这类属性)</p></blockquote><h3 id="Q5-判断下面两段代码分别输出什么？"><a href="#Q5-判断下面两段代码分别输出什么？" class="headerlink" title="Q5:判断下面两段代码分别输出什么？"></a><strong>Q5:判断下面两段代码分别输出什么？</strong></h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo1'</span>);&#125;foo(); <span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo2'</span>);&#125;foo();</code></pre><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo1'</span>);&#125;foo(); <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo2'</span>);&#125;foo();</code></pre><blockquote><p>第一段会打印：foo1 和 foo2 变量声明提升 （提升为undefined，边执行边赋值）<br>第二段会打印：foo2 和 foo2 函数声明提升 （函数提升，当重复时后一个会对前一个进行覆盖）</p></blockquote><h3 id="Q6-判断下面这段代码输出什么？"><a href="#Q6-判断下面这段代码输出什么？" class="headerlink" title="Q6:判断下面这段代码输出什么？"></a><strong>Q6:判断下面这段代码输出什么？</strong></h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">var</span> b = a;a.x = a = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">2</span>&#125;;<span class="hljs-built_in">console</span>.log(a.x)<span class="hljs-built_in">console</span>.log(b.x)</code></pre><blockquote><p>a.x：undefined<br>b.x：{n: 2}<br>原因：</p><ul><li>1、优先级。<code>.</code>的优先级高于<code>=</code>，所以先执行<code>a.x</code>，堆内存中的<code>{n: 1}</code>就会变成<code>{n: 1, x: undefined}</code>，改变之后相应的<code>b.x</code>也变化了，因为指向的是同一个对象。</li><li>2、赋值操作是<code>从右到左</code>，所以先执行<code>a = {n: 2}</code>，<code>a</code>的引用就被改变了，然后这个返回值又赋值给了<code>a.x</code>，<strong>需要注意</strong>的是这时候<code>a.x</code>是第一步中的<code>{n: 1, x: undefined}</code>那个对象，其实就是<code>b.x</code>，相当于<code>b.x = {n: 2}</code></li></ul></blockquote><h3 id="Q7-判断下面两段代码的this对象是什么及输出什么？"><a href="#Q7-判断下面两段代码的this对象是什么及输出什么？" class="headerlink" title="Q7:判断下面两段代码的this对象是什么及输出什么？"></a><strong>Q7:判断下面两段代码的this对象是什么及输出什么？</strong></h3><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;  name: <span class="hljs-string">"personName"</span>,  getName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;  &#125;&#125;<span class="hljs-built_in">console</span>.log(person.getName());</code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"windowName"</span>;<span class="hljs-keyword">var</span> person = &#123;  name: <span class="hljs-string">"axuebin"</span>,  getName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;  &#125;&#125;<span class="hljs-keyword">var</span> getName = person.getName;<span class="hljs-built_in">console</span>.log(getName());</code></pre><blockquote><p>第一段会打印：personName  this指向person<br>第二段会打印：windowName this指向全局变量<br>this的指向取决于函数调用时</p></blockquote><h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><ul><li><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener"><strong>《JavaScript高级程序设计(第3版)》</strong></a></li><li><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener"><strong>冴羽JavaScript深入系列15篇</strong></a></li><li><a href="https://www.jianshu.com/p/d647aa6d1ae6" target="_blank" rel="noopener"><strong>前端基础进阶（七）：全方位解读this</strong></a></li><li><a href="https://muyiy.cn/blog/1/1.1.html" target="_blank" rel="noopener"><strong>木易杨前端进阶-第 1 期：调用堆栈</strong></a></li><li><a href="https://muyiy.cn/blog/2/2.1.html" target="_blank" rel="noopener"><strong>木易杨前端进阶-第 2 期：作用域闭包</strong></a></li><li><a href="https://muyiy.cn/blog/3/3.1.html#_1-%E8%B0%83%E7%94%A8%E4%BD%8D%E7%BD%AE" target="_blank" rel="noopener"><strong>木易杨前端进阶-第 3 期：this全面解析</strong></a></li><li><a href="https://juejin.im/post/5ba32171f265da0ab719a6d7" target="_blank" rel="noopener"><strong>理解 JavaScript 中的执行上下文和执行栈</strong></a></li><li><a href="https://github.com/axuebin/articles/issues/6" target="_blank" rel="noopener"><strong>JavaScript基础心法——this</strong></a></li><li><a href="https://github.com/kuitos/kuitos.github.io/issues/18" target="_blank" rel="noopener"><strong>一道js面试题引发的思考</strong></a></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>欢迎纠错，看到会及时修改哒！❤<br>温故而知新，希望我们都可以保持本心，念念不忘，必有回响。</p>]]></content>
    
    
    <categories>
      
      <category>技术blog</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从 Promises/A+ 规范瞅一瞅 Promise</title>
    <link href="/2020/06/20/technology/promiseA+/"/>
    <url>/2020/06/20/technology/promiseA+/</url>
    
    <content type="html"><![CDATA[<blockquote><p>先进行一些基本的概念梳理：</p></blockquote><h3 id="什么是-Promise？"><a href="#什么是-Promise？" class="headerlink" title="什么是 Promise？"></a>什么是 Promise？</h3><p><code>Promise</code> 是异步编程的一种解决方案：从语法上讲，<code>Promise</code>是一个对象，它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p><h3 id="Promise-可以解决什么问题？"><a href="#Promise-可以解决什么问题？" class="headerlink" title="Promise 可以解决什么问题？"></a>Promise 可以解决什么问题？</h3><ul><li><strong>回调地狱</strong>，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</li></ul><p>当异步场景越来越多的时候，代码会横向发展（变宽），依赖的层级逐渐变多，会不停的进行嵌套 ，最终导致回调地狱。<code>Promise</code>实际上是使异步调用更加链式了，可以将异步操作队列化，按照期望的顺序依次进行执行，返回符合预期的结果。</p><ul><li><code>Promise</code>可以支持多个并发的请求，获取并发请求中的数据</li><li><code>Promise</code>可以解决异步的问题，但本身不能说 promise 是异步的</li></ul><h4 id="举个-🌰"><a href="#举个-🌰" class="headerlink" title="举个 🌰"></a>举个 🌰</h4><pre><code class="hljs javascript"><span class="hljs-comment">//回调函数</span><span class="hljs-keyword">const</span> callback=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'callback'</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callbackFn</span>(<span class="hljs-params">fn</span>)</span>&#123;    setTimeout(fn,<span class="hljs-number">3000</span>)&#125;callbackFn(callback)<span class="hljs-comment">//封装成promise</span><span class="hljs-keyword">const</span> promise =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'success'</span>)    resolve()&#125;)promise.then(    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        setTimeout(callback,<span class="hljs-number">3000</span>)    &#125;)</code></pre><h3 id="Promise-优缺点"><a href="#Promise-优缺点" class="headerlink" title="Promise 优缺点"></a>Promise 优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>把执行代码和处理代码分离开，使异步操作逻辑更加清晰。</li><li>可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数(并未剥夺函数<code>return</code>的能力，因此无需层层传递<code>callback</code>，进行回调获取数据)</li><li>对象提供统一的接口，使得控制异步操作更加容易</li><li>代码风格，容易理解，便于维护</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法取消 <code>Promise</code>，一旦新建它就会立即执行，无法中途取消</li><li>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</li><li>当处于<code>Pending</code>状态时，无法得知目前进展到哪一个阶段</li></ul><h3 id="Promise-三种状态"><a href="#Promise-三种状态" class="headerlink" title="Promise 三种状态"></a>Promise 三种状态</h3><ul><li>初始状态：<code>pending</code>(等待态)</li><li>操作成功：<code>fulfilled</code>(成功态)</li><li>操作失败：<code>rejected</code>(失败态)</li></ul><h3 id="Promise-使用"><a href="#Promise-使用" class="headerlink" title="Promise 使用"></a>Promise 使用</h3><p><code>Promise</code>的构造函数接收一个函数作为参数，并且这个函数需要传入两个参数：</p><ul><li><code>resolve()</code>: 异步操作执行成功后的回调函数,将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li><li><code>reject()</code>: 异步操作执行失败后的回调函数,将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。在执行<code>resolve</code>的回调时，如果抛出异常了（代码出错了），那么并不会报错卡死<code>js</code>，而是会进到这个<code>catch</code>方法中。</li><li>当<code>Promise</code>状态发生改变，就会触发<code>then()</code>里的响应函数处理后续步骤；创造<code>Promise</code>实例后，它会立即执行，<code>Promise</code>状态一经改变，不会再变。</li><li>当出现<code>.then()</code>里面有<code>.then()</code>的情况时，由于<code>.then()</code>返回的还是 Promise 实例，会等里面的<code>.then()</code>执行完，再执行外面的</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-comment">//做一些异步操作</span>      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.random()*<span class="hljs-number">10</span>); <span class="hljs-comment">//生成1-10的随机数</span>            <span class="hljs-keyword">if</span>(num&lt;=<span class="hljs-number">5</span>)&#123;                resolve(num);            &#125;            <span class="hljs-keyword">else</span>&#123;                reject(<span class="hljs-string">'数字太大了'</span>);            &#125;      &#125;, <span class="hljs-number">2000</span>);    &#125;);    p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'resolved'</span>,data);        &#125;,(err) =&gt; &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'rejected'</span>,err);        &#125;    );</code></pre><h3 id="Promises-A-规范（划重点）"><a href="#Promises-A-规范（划重点）" class="headerlink" title="Promises/A+ 规范（划重点）*"></a>Promises/A+ 规范（划重点）*</h3><p>其实归根结底，<code>Promises/A+</code> 规范为整个<code>Promise</code>的执行和使用提供了完整的解释，所有对<code>Promise</code>的疑问都能在这里得到解答。</p><p>先上一个官方地址：<a href="https://promisesaplus.com/" target="_blank" rel="noopener">https://promisesaplus.com</a></p><blockquote><p>由于官网是英文版本，为了便于阅读和理解，结合 Google 翻译自己转译了一下，水平有限，有问题欢迎指正，感恩的心 💗💗</p></blockquote><h4 id="规范正文：（举-🌰-补充）"><a href="#规范正文：（举-🌰-补充）" class="headerlink" title="规范正文：（举 🌰 补充）"></a>规范正文：（举 🌰 补充）</h4><pre><code>**一个由实施者提供的开放的，可实现的，可互操作的 JavaScript 承诺的标准，对于实施者。**一个`Promise`表示异步操作的最终结果。与承诺进行交互的主要方式是通过其`then`方法，该方法注册回调以接收承诺的最终值或无法实现承诺的原因。该规范详细介绍了该`then`方法的行为，提供了可互操作的基础，所有`Promises / A +`兼容的`Promise`实现都可以依靠该基础来提供。因此，该规范应被认为是非常稳定的。尽管 Promises / A +组织有时会通过向后兼容的微小更改来修订此规范，以解决新发现的极端情况，但只有经过仔细考虑，讨论和测试之后，我们才会集成大型或向后兼容的更改。从历史上看，`Promises / A +`阐明了较早的`Promises / A`提案的行为条款，将其扩展为涵盖事实上的行为，并省略了未指定或有问题的部分。最后，核心的`Promises / A +`规范不涉及如何创建，履行或拒绝诺言，而是专注于提供一种可互操作的`then`方法。未来工作中伴随着这些规范可能涉及到这些主题。</code></pre><h5 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h5><ul><li><code>Promise</code>是具有 then 方法的符合本规范的对象或函数。（<strong>狭义认为一个对象只要有 then 方法就是一个合法的 promise 对象）</strong></li><li><code>thenable</code>（包含<code>then</code>方法）是定义<code>then</code>方法的对象或函数。</li><li><code>value（值）</code>是任何合法的<code>JavaScript</code>值（包括<code>undefined</code>，<code>thenable</code>或<code>promise</code>）。</li><li><code>exception（异常）</code>是使用该 throw 语句引发的值。</li><li><code>reason（原因）</code>是表明拒绝承诺的原因的值。</li></ul><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><h5 id="promise-的状态"><a href="#promise-的状态" class="headerlink" title="promise 的状态"></a>promise 的状态</h5><p>一个<code>promise</code>必须处于以下三种状态之一：等待中（<code>pending</code>），已完成（<code>fulfilled</code>）或已拒绝（<code>rejected</code>）。</p><ul><li>处于等待中：<ul><li>可能会转换为已完成或已拒绝状态。</li></ul></li><li>当已完成时：<ul><li>不得过渡到任何其他状态。</li><li>必须具有一个值，该值不能更改。</li></ul></li><li>当已拒绝时：<ul><li>不得过渡到任何其他状态。</li><li>必须有一个原因，不能改变。</li></ul></li></ul><p>在此，“不得更改”是指不变的身份（即===），但并不表示深层的不变性。</p><h5 id="一个-then-方法"><a href="#一个-then-方法" class="headerlink" title="一个 then 方法"></a>一个 then 方法</h5><p>一个承诺必须提供一个<code>then</code>方法来访问其当前或最终值或原因。</p><p><code>Promise</code>的<code>then</code>方法接受两个参数：</p><blockquote><p>promise.then(onFulfilled, onRejected)</p></blockquote><ul><li><p>这两个<code>onFulfilled</code>和<code>onRejected</code>是可选的参数：</p><ul><li>如果 <code>onFulfilled</code> 不是函数，则必须将其忽略。</li><li>如果 <code>onRejected</code> 不是函数，则必须将其忽略。</li></ul></li><li><p>如果 <code>onFulfilled</code> 是一个函数：</p><ul><li>必须在 <code>promise 执行结束后调用，以</code>promise` 的结果作为第一个参数。</li><li>在 <code>promise</code> 执行结束之前不能调用它。</li><li>不能多次调用。</li></ul></li><li><p>如果 <code>onRejected</code> 是一个函数:</p><ul><li>必须在 <code>promise</code> 被拒绝之后调用，以 <code>promise</code> 的原因作为第一个参数。</li><li>在 <code>promise</code> 被拒绝之前不能调用它。</li><li>不能多次调用。</li></ul></li><li><p><code>onFulfilled</code> 或 <code>onRejected</code> 在执行上下文堆栈仅包含平台代码之前不得调用。</p></li><li><p><code>onFulfilled</code> 和 <code>onRejected</code> 必须作为普通函数调用（即没有 this 值）（非实例化调用，<code>this</code> 在非严格模式下会指向 <code>window</code>）。</p></li><li><p>then 可能在同一 promise 中多次被调用。</p><ul><li>当 <code>promise</code> 完成时，则所有相应的 <code>onFulfilled</code> 必须按照其注册顺序执行 <code>then</code>。</li><li>当 <code>promise</code> 被拒绝时，则所有相应的 <code>onRejected</code> 必须按照其注册顺序执行 <code>then</code>。<blockquote><p>promise2 = promise1.then(onFulfilled, onRejected);</p></blockquote></li></ul></li><li><p><code>then</code> 必须返回 <code>promise</code>。</p><ul><li>如果有一个 <code>onFulfilled</code> 或 <code>onRejected</code> 返回一个值 x，<code>promise2</code> 进入 <code>onFulfilled</code> 状态。[1]</li><li>如果任何一个 <code>onFulfilled</code> 或 <code>onRejected</code> 引发一个异常 e，则 <code>promise2</code> 必须拒绝 e 并返回拒绝原因。[2]</li><li>如果<code>onFulfilled</code> 不是函数且 <code>promise1</code> 已完成，则 <code>promise2</code> 必须使用相同的值来完成 <code>promise1</code>（成功）。[3]</li><li>如果 <code>onRejected</code> 不是函数而 <code>promise1</code> 被拒绝，则 <code>promise2</code> 必须以与相同的理由将其拒绝（失败）。[4]</li></ul></li></ul><p><strong>（每一个 <code>promise</code> 只取决于上一个 <code>promise</code> 的结果）</strong></p><h5 id="对照上面四条标准，这个地方举几个-🌰-来看一下-promise-的输出：（判断一下以下几种情况分别输出什么？）"><a href="#对照上面四条标准，这个地方举几个-🌰-来看一下-promise-的输出：（判断一下以下几种情况分别输出什么？）" class="headerlink" title="对照上面四条标准，这个地方举几个 🌰 来看一下 promise 的输出：（判断一下以下几种情况分别输出什么？）"></a>对照上面四条标准，这个地方举几个 🌰 来看一下 promise 的输出：（判断一下以下几种情况分别输出什么？）</h5><p><strong>（1）</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;    reject()&#125;)promise1    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;    &#125;, <span class="hljs-literal">null</span>)    .then(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)    .then(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'success promise'</span>)    &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error promise'</span>)    &#125;)</code></pre><p>输出<code>error promise</code></p><p>首先<code>promise1</code>进入<code>onRejected</code>状态，返回的值为<code>null</code>，不是一个函数，参照上方第[4]条，不停向下<code>onRejected</code>直到<code>console.log(&#39;error promise&#39;)</code><br><strong>（2）</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;   reject()&#125;)promise1    .then(<span class="hljs-literal">null</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">456</span>;    &#125;)    .then(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)    .then(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'success promise'</span>)    &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error promise'</span>)    &#125;)</code></pre><p>输出<code>success promise</code></p><p>首先<code>promise1</code>进入<code>onRejected</code>状态，函数返回一个值为 456，参照上方第[1]条，此时<code>promise2</code>进入 <code>onFulfilled</code> 状态，参照上方第[4]条，不停向下完成直到<code>console.log(&#39;success promise&#39;)</code></p><p><strong>（3）</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;    resolve()&#125;)promise1    .then(<span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">456</span>;    &#125;)    .then(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)    .then(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'e'</span>)    &#125;, <span class="hljs-literal">null</span>)    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'success promise'</span>)    &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'error promise'</span>)    &#125;)</code></pre><p>输出<code>error promise</code></p><p>首先<code>promise1</code>进入<code>onFulfilled</code>状态，返回<code>null</code>，参照上方第[4]条，不停向下完成直到抛出异常<code>e</code>，参照上方第[2]条，此时进入<code>onRejected</code>状态，向下输出<code>console.log(&#39;success promise&#39;)</code></p><h5 id="promise-解决过程"><a href="#promise-解决过程" class="headerlink" title="promise 解决过程"></a>promise 解决过程</h5><p><code>promise</code> 解决过程是一个抽象的操作，输入一个 <code>promise</code> 和一个值，它表示为<code>[[Resolve]](promise, x)</code>。如果 x 是 <code>thenable</code> 的，则其行为类似于 <code>promise</code>，尝试使 <code>promise</code> 采用 x 的状态。否则，它将使用 <code>value</code>。</p><p>只要对约定的实现公开 <code>Promises / A +</code>兼容的 <code>then</code> 方法，对约定的实现就可以进行互操作。它还允许<code>Promises / A +</code>实现以合理的 <code>then</code> 方法“同化”不合格的实现。<br>要运行<code>[[Resolve]](promise, x)</code>，请执行以下步骤：</p><ul><li>如果 <code>promise</code> 和 <code>x</code> 引用相同的对象，则以 <code>TypeError</code> 为理由拒绝<code>promise</code>。</li><li>如果 <code>x</code> 是一个 <code>promise</code>，则采用其状态：<ul><li>如果 <code>x</code> 等待中，则 <code>promise</code> 必须保持等待状态，直到 <code>x</code> 已完成或已拒绝。[1]</li><li>如果 <code>x</code> 已完成，<code>promise</code> 则以相同的值完成。[2]</li><li>如果 <code>x</code> 已拒绝，<code>promise</code> 则以相同的理由拒绝。[3]<strong>（.then()的状态取决于返回的 promise 的状态）</strong></li></ul></li></ul><h5 id="再举个-🌰"><a href="#再举个-🌰" class="headerlink" title="再举个 🌰"></a>再举个 🌰</h5><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> promise1 =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;    resolve(<span class="hljs-string">'promise1'</span>)&#125;)<span class="hljs-keyword">var</span> promise2 =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;    resolve(<span class="hljs-string">'promise2'</span>)&#125;)promise1.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;    <span class="hljs-keyword">return</span> promise2&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(val)&#125;)</code></pre><p>输出<code>promise2</code>，参照上方第[2]条</p><ul><li>否则，如果 <code>x</code> 是对象或函数（不太常见）<ul><li>先执行 <code>x.then</code>。</li><li>如果取 <code>x.then</code> 中值时抛出异常的结果 e，以 e 作为原因拒绝 <code>promise</code>。</li><li>如果 <code>then</code> 是函数，请使用 <code>x</code> 作为 <code>this</code>，第一个参数 <code>resolvePromise</code> 和第二个参数 <code>rejectPromise</code> 进行调用，其中：<ul><li>如果 <code>resolvePromise</code> 调用 <code>y</code> 作为值，请运行<code>[[Resolve]](promise, y)</code>。</li><li>如果 <code>rejectPromise</code> 调用 <code>r</code> 作为拒因，以 <code>r</code> 作为原因拒绝 <code>promise</code>。</li><li>如果同时调用 <code>resolvePromise</code> 和 <code>rejectPromise</code>，或者对同一个参数进行了多次调用，则第一个调用优先，其他任何调用都将被忽略。</li><li>如果调用 <code>then</code> 引发异常 <code>e</code>，<ul><li>如果 <code>resolvePromise</code>或 <code>rejectPromise</code> 已经被调用，则忽略它。</li><li>否则，以 <code>e</code> 作为原因拒绝 <code>promise</code>。</li></ul></li></ul></li><li>如果 <code>then</code> 不是函数，<code>promise</code> 调用 <code>x</code> 变为已完成状态。</li></ul></li><li>如果 <code>x</code> 不是一个对象或函数，<code>promise</code> 调用 <code>x</code> 变为已完成状态（常见）。</li></ul><h5 id="又来一个-🌰"><a href="#又来一个-🌰" class="headerlink" title="又来一个 🌰"></a>又来一个 🌰</h5><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> promise1 =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;    resolve(<span class="hljs-string">'promise1'</span>)&#125;)<span class="hljs-keyword">var</span> promise2 =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;    resolve(<span class="hljs-string">'promise2'</span>)&#125;)promise1.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;    <span class="hljs-keyword">return</span> val&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(val)&#125;)</code></pre><p>输出<code>promise1</code>，<code>x</code>不是一个对象或函数</p><p>如果使用在一个循环链中的 <code>thenable</code> 来解决 <code>promise</code>，<code>[[Resolve]](promise, thenable)</code>会导致递归，<code>[[Resolve]](promise, thenable)</code>将被再次调用，以上会导致无限递归。推荐（但不是必需），检测这种递归并以<code>TypeError</code> 为理由拒绝 <code>promise</code>。</p><h3 id="手写一个Promise"><a href="#手写一个Promise" class="headerlink" title="手写一个Promise"></a>手写一个Promise</h3><p>根据promiseA+实现一个自己的promise，这里不多讲解了，文末会推荐几篇自己觉得比较好的文章</p><p>（其实是我自己在写的还没完善好，等写满意了再回来补坑）</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1542493/1593049540238-f5ac61fc-eacb-4e02-aa61-3d8d0aeffcd7.png#align=left&display=inline&height=119&margin=%5Bobject%20Object%5D&originHeight=119&originWidth=126&size=0&status=done&style=none&width=126" srcset="/img/loading.gif" alt=""></p><h3 id="介绍几个Promise常用的方法"><a href="#介绍几个Promise常用的方法" class="headerlink" title="介绍几个Promise常用的方法"></a>介绍几个Promise常用的方法</h3><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象</p><p>并行执行异步操作的能力（没有顺序），并且在所有异步操作执行完后才执行回调。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">time</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;        <span class="hljs-keyword">return</span> setTimeout(resolve(time), time);    &#125;)&#125;<span class="hljs-built_in">Promise</span>.all([promise(<span class="hljs-number">1000</span>), promise(<span class="hljs-number">3000</span>)]).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'all'</span>, values.toString()) <span class="hljs-comment">// 三个都成功则成功 </span>&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(e) <span class="hljs-comment">// 只要有失败，则失败 </span>&#125;)</code></pre><p>3秒后输出 <code>all 1000,3000</code></p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>谁跑的快，以谁为准执行回调。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">time</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;        <span class="hljs-keyword">return</span> setTimeout(resolve(time), time);    &#125;)&#125;<span class="hljs-built_in">Promise</span>.race([promise(<span class="hljs-number">1000</span>),promise(<span class="hljs-number">3000</span>)]).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'race'</span>,value)&#125;)</code></pre><p>1秒后输出 <code>race 1000</code></p><p>可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p><pre><code class="hljs javascript"><span class="hljs-comment">//请求某个图片资源</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestImg</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();        img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;            resolve(img);        &#125;        img.src = <span class="hljs-string">'图片的路径'</span>;    &#125;);    <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">//延时函数，用于给请求计时</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            reject(<span class="hljs-string">'图片请求超时'</span>);        &#125;, <span class="hljs-number">5000</span>);    &#125;);    <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-built_in">Promise</span>.race([requestImg(), timeout()]).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(data);&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(err);&#125;);</code></pre><h3 id="巨人的肩膀（包括认为比较好的手写Promise文章）"><a href="#巨人的肩膀（包括认为比较好的手写Promise文章）" class="headerlink" title="巨人的肩膀（包括认为比较好的手写Promise文章）"></a>巨人的肩膀（包括认为比较好的手写Promise文章）</h3><ul><li><a href="https://juejin.im/post/5afe6d3bf265da0b9e654c4b" target="_blank" rel="noopener">Promise不会？？看这里！！！史上最通俗易懂的Promise！！！</a></li><li><a href="https://juejin.im/post/5b16800fe51d4506ae719bae#heading-30" target="_blank" rel="noopener">一起学习造轮子（一）：从零开始写一个符合Promises/A+规范的promise</a></li><li><a href="https://mp.weixin.qq.com/s/qdJ0Xd8zTgtetFdlJL3P1g" target="_blank" rel="noopener">100 行代码实现 Promises/A+ 规范</a></li><li><a href="https://juejin.im/post/5b83cb5ae51d4538cc3ec354" target="_blank" rel="noopener">Promise实现原理（附源码）</a></li><li><a href="https://juejin.im/post/5a04066351882517c416715d" target="_blank" rel="noopener">Promise 必知必会（十道题）</a></li><li><a href="https://juejin.im/post/5b2f02cd5188252b937548ab#heading-9" target="_blank" rel="noopener">BAT前端经典面试问题：史上最最最详细的手写Promise教程</a></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h3><p>欢迎纠错，看到会及时修改哒！❤<br>温故而知新，希望我们都可以保持本心，念念不忘，必有回响。</p>]]></content>
    
    
    <categories>
      
      <category>技术blog</category>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue组件通信--provide/inject</title>
    <link href="/2020/06/08/technology/vue-provider/"/>
    <url>/2020/06/08/technology/vue-provider/</url>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>之前在Vue中进行组件通信一般都会使用props，开始使用provide/inject是非常偶然的一次尝试。<br>当时在开发中需要实现祖孙组件，甚至祖祖祖祖孙组件之间的通信，在这种多层级场景下，props就显得太过累赘了，由于是进行设计器（插件）开发，为了提高插件的可复用性，减少不必要的包依赖，倾向于在不引入Vuex的情况下解决这个问题，那么就应该看看vue本身，是否具有这种能力，就在这个时候，我发现了provide/inject。</p><h2 id="我们先来看看Vue官方的定义是什么："><a href="#我们先来看看Vue官方的定义是什么：" class="headerlink" title="我们先来看看Vue官方的定义是什么："></a>我们先来看看Vue官方的定义是什么：</h2><p><img src="http://note.youdao.com/yws/res/3837/WEBRESOURCE8aaa8269c294a376ba32fa631da1ee75#align=left&display=inline&height=475&margin=%5Bobject%20Object%5D&originHeight=703&originWidth=917&status=done&style=none&width=620" srcset="/img/loading.gif" alt=""><br>provide/inject 是 Vue 在 2.2.0 版本新增的 API，官网这段定义看起来好像有点难理解，通俗的讲，就是provide 可以在祖先组件中指定我们想要提供给后代组件的数据或方法，而在任何后代组件中，我们都可以使用 inject 来接收 provide 提供的数据或方法。</p><h2 id="举个🌰："><a href="#举个🌰：" class="headerlink" title="举个🌰："></a>举个🌰：</h2><pre><code class="hljs javascript"><span class="hljs-comment">// 父级组件提供 'foo'</span>&lt;template&gt;  &lt;div&gt;    &lt;div&gt;&#123;&#123;foo&#125;&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">    &lt;son&gt;&lt;/</span>son&gt;  &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">&lt;/</span>template&gt;&lt;script&gt;<span class="hljs-keyword">import</span> Son <span class="hljs-keyword">from</span> <span class="hljs-string">"./Son"</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">"parent"</span>,  components: &#123; Son &#125;,  provide() &#123;    <span class="hljs-keyword">return</span> &#123;      foo: <span class="hljs-keyword">this</span>.foo    &#125;;  &#125;,  data() &#123;    <span class="hljs-keyword">return</span> &#123;      foo: <span class="hljs-string">"测试"</span>,    &#125;;  &#125;，  mounted() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.foo)  &#125;,&#125;;&lt;<span class="hljs-regexp">/script&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">/</span><span class="hljs-regexp">/子级组件，不接收</span><span class="hljs-regexp">&lt;template&gt;</span><span class="hljs-regexp">  &lt;grandSon&gt;&lt;/g</span>randSon&gt;&lt;<span class="hljs-regexp">/template&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">&lt;script&gt;</span><span class="hljs-regexp">import grandSon from "./g</span>randSon<span class="hljs-string">";</span><span class="hljs-string">export default &#123;</span><span class="hljs-string">  name: "</span>son<span class="hljs-string">",</span><span class="hljs-string">  components: &#123; grandSon &#125;,</span><span class="hljs-string">&#125;;</span><span class="hljs-string">&lt;/script&gt;</span><span class="hljs-string"></span><span class="hljs-string">//孙级组件，接收foo</span><span class="hljs-string">&lt;template&gt;</span><span class="hljs-string">  &lt;div&gt;&#123;&#123;foo&#125;&#125;&lt;/div&gt;</span><span class="hljs-string">&lt;/template&gt;</span><span class="hljs-string"></span><span class="hljs-string">&lt;script&gt;</span><span class="hljs-string">export default &#123;</span><span class="hljs-string">  name: "</span>grandSon<span class="hljs-string">",</span><span class="hljs-string">  inject: ["</span>foo<span class="hljs-string">"],</span><span class="hljs-string">  mounted() &#123;</span><span class="hljs-string">    console.log(this.foo)</span><span class="hljs-string">  &#125;,</span><span class="hljs-string">&#125;;</span><span class="hljs-string">&lt;/script&gt;</span></code></pre><p>在这里我们可以发现孙组件越过子组件接收了父组件注入的数据，我们可以理解为爷爷越过爸爸偷偷给孙子买了冰激凌，这是一组最简单的用法，当层级继续增加时，仍可通过这种方式由父组件直接跨域多个层级向后代组件注入数据。<br>有一点需要特别注意的是，实际上我们可以将当前组件inject获取的数据直接赋值给它本身的data或props，不过官网提示我们，这是在Vue2.2.1版本才实现的功能，在这之前，必须先进行props和data数据的初始化。<br><img src="http://note.youdao.com/yws/res/3886/WEBRESOURCE81d3c0312bc39b56e0f5ff4fdba4dc6b#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&originHeight=100&originWidth=857&status=done&style=none&width=620" srcset="/img/loading.gif" alt=""></p><h2 id="实现可响应的数据变化"><a href="#实现可响应的数据变化" class="headerlink" title="实现可响应的数据变化"></a>实现可响应的数据变化</h2><p>在尝试中我们发现，由于Vue的单向流关系，实际上如果在parent中改变了初始传入的foo的值以后，grandSon并不会得到改变后的值，也就是在这个时候，父孙组件的数据出现了不一致的情况，我们肯定是希望拿到的数据是一致的，怎么来解决这个问题呢，官网还有一句提示为我们提供了解释。<br><img src="http://note.youdao.com/yws/res/3911/WEBRESOURCEcff4660c1175a82fe1c03e986b6f3ed3#align=left&display=inline&height=69&margin=%5Bobject%20Object%5D&originHeight=97&originWidth=876&status=done&style=none&width=620" srcset="/img/loading.gif" alt=""><br>也就是指，我们需要人为的将这组数据关系变成可响应的，哦，我们之前的foo是一个字符串，基本数据类型是不具有响应特性的，那么，我们可能需要传递一个对象。</p><h2 id="再举个🌰："><a href="#再举个🌰：" class="headerlink" title="再举个🌰："></a>再举个🌰：</h2><pre><code class="hljs javascript"><span class="hljs-comment">// 改造一下父级组件提供 'foo'</span>&lt;template&gt;  &lt;div&gt;    &lt;div&gt;&#123;&#123;foo&#125;&#125;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">    &lt;son&gt;&lt;/</span>son&gt;  &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">&lt;/</span>template&gt;&lt;script&gt;<span class="hljs-keyword">import</span> Son <span class="hljs-keyword">from</span> <span class="hljs-string">"./Son"</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">"parent"</span>,  components: &#123; Son &#125;,  provide() &#123;    <span class="hljs-keyword">return</span> &#123;      foo: <span class="hljs-keyword">this</span>.foo    &#125;;  &#125;,  data() &#123;    <span class="hljs-keyword">return</span> &#123;      foo: &#123;        foo: <span class="hljs-string">"测试"</span>      &#125;,,    &#125;;  &#125;，  mounted() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.foo)  &#125;,&#125;;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><p>在这个栗子中，改造了一下父组件提供的数据，测试发现，foo变成了一组可响应的数据。经过尝试我发现在这种情况下如果在孙组件改变inject中foo的值，也会响应的更新到父组件中，当然为了保护单向数据流机制，最佳实践还是不要在子组件里更改inject（虽然 sync 也破坏了单向数据流）。</p><h2 id="实现可响应的数据变化默认值设置"><a href="#实现可响应的数据变化默认值设置" class="headerlink" title="实现可响应的数据变化默认值设置"></a>实现可响应的数据变化默认值设置</h2><p><img src="http://note.youdao.com/yws/res/3944/WEBRESOURCEa1f2da7f56ea03e708af405a0c882d18#align=left&display=inline&height=79&margin=%5Bobject%20Object%5D&originHeight=79&originWidth=595&status=done&style=none&width=595" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs javascript">&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">"grandSon"</span>,  inject: &#123;    foo: &#123;      <span class="hljs-keyword">from</span>: <span class="hljs-string">'bar'</span>,      <span class="hljs-keyword">default</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]    &#125;  &#125;,  mounted() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.foo)  &#125;,&#125;;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><p>在2.5.0 版本之后的版本中可以为inject提供默认值了，如果它需要从一个不同名字的 property 注入，则使用 from 来表示其源 property，与 prop 的默认值类似，需要对非原始值使用一个工厂方法。</p><p>呱唧呱唧，那基本用法我们就讲到这里了，归根结底，既然provide/inject 这么方便，为什么 Vue 官方还要推荐我们使用 Vuex进行数据管理呢？</p><h2 id="明显的缺点"><a href="#明显的缺点" class="headerlink" title="明显的缺点"></a>明显的缺点</h2><p>provide/inject 的缺点还是非常明显的</p><ul><li><p>当多个后代组件同时依赖同一个父组件提供数据时，只要任一组件对数据进行了修改，所有依赖的组件都会受到影响，实际上是增加了耦合度。</p></li><li><p>任意层级访问使数据追踪变的比较困难，你并不能准确的定位到是哪一个层级对数据进行了改变，当数据出现问题时，尤其是多人协作时，可能会大大增加问题定位的损耗。</p><h2 id="值得肯定的优点"><a href="#值得肯定的优点" class="headerlink" title="值得肯定的优点"></a>值得肯定的优点</h2><p>万事万物都有把双刃剑，有缺点自然也有优点，在进行组件库或高级插件开发时，provide/inject 仍然是一个不错的选择。</p><h2 id="留坑待补（慢慢完善。。。应当不会鸽）"><a href="#留坑待补（慢慢完善。。。应当不会鸽）" class="headerlink" title="留坑待补（慢慢完善。。。应当不会鸽）"></a>留坑待补（慢慢完善。。。应当不会鸽）</h2></li><li><p>从Vue生命周期源码来看provide/inject的执行过程</p></li><li><p>插件/组件库应用实例（同样的功能实现与Vuex进行对比）</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实之前的笔记都是写给自己看的，这还是真正意义上的第一篇热乎乎的博客，emmm感觉还有些地方没有讲的很明白，也还留坑了一些内容后续会慢慢完善，输出真是不易的过程，不过会继续努力学习提高哒，有问题欢迎指出，会及时更正，奥里给！<br>欢迎纠错，看到会及时修改哒！❤<br>温故而知新，希望我们都可以保持本心，念念不忘，必有回响。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术blog</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
